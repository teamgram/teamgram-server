// Code generated by protoc-gen-gogo. DO NOT EDIT.
// source: authsession.tl.proto

package authsession

import (
	context "context"
	fmt "fmt"
	_ "github.com/gogo/protobuf/gogoproto"
	proto "github.com/gogo/protobuf/proto"
	_ "github.com/gogo/protobuf/types"
	mtproto "github.com/teamgram/proto/mtproto"
	grpc "google.golang.org/grpc"
	codes "google.golang.org/grpc/codes"
	status "google.golang.org/grpc/status"
	io "io"
	math "math"
	math_bits "math/bits"
	reflect "reflect"
	strings "strings"
)

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.GoGoProtoPackageIsVersion3 // please upgrade the proto package

type TLConstructor int32

const (
	CRC32_UNKNOWN                          TLConstructor = 0
	CRC32_clientSession                    TLConstructor = -1701940816
	CRC32_authKeyStateData                 TLConstructor = -646863312
	CRC32_authsession_getAuthorizations    TLConstructor = 820122180
	CRC32_authsession_resetAuthorization   TLConstructor = -1923126106
	CRC32_authsession_getLayer             TLConstructor = -1473309015
	CRC32_authsession_getLangPack          TLConstructor = 700170598
	CRC32_authsession_getClient            TLConstructor = 1616401854
	CRC32_authsession_getLangCode          TLConstructor = 1486468441
	CRC32_authsession_getUserId            TLConstructor = 1464409260
	CRC32_authsession_getPushSessionId     TLConstructor = -1279119039
	CRC32_authsession_getFutureSalts       TLConstructor = -1194371051
	CRC32_authsession_queryAuthKey         TLConstructor = 1421293608
	CRC32_authsession_setAuthKey           TLConstructor = 1049889937
	CRC32_authsession_bindAuthKeyUser      TLConstructor = 198050851
	CRC32_authsession_unbindAuthKeyUser    TLConstructor = 123258440
	CRC32_authsession_getPermAuthKeyId     TLConstructor = -1871420202
	CRC32_authsession_bindTempAuthKey      TLConstructor = 1620004742
	CRC32_authsession_setClientSessionInfo TLConstructor = 47841172
	CRC32_authsession_getAuthorization     TLConstructor = 1851660579
	CRC32_authsession_getAuthStateData     TLConstructor = 1331573041
)

var TLConstructor_name = map[int32]string{
	0:           "CRC32_UNKNOWN",
	-1701940816: "CRC32_clientSession",
	-646863312:  "CRC32_authKeyStateData",
	820122180:   "CRC32_authsession_getAuthorizations",
	-1923126106: "CRC32_authsession_resetAuthorization",
	-1473309015: "CRC32_authsession_getLayer",
	700170598:   "CRC32_authsession_getLangPack",
	1616401854:  "CRC32_authsession_getClient",
	1486468441:  "CRC32_authsession_getLangCode",
	1464409260:  "CRC32_authsession_getUserId",
	-1279119039: "CRC32_authsession_getPushSessionId",
	-1194371051: "CRC32_authsession_getFutureSalts",
	1421293608:  "CRC32_authsession_queryAuthKey",
	1049889937:  "CRC32_authsession_setAuthKey",
	198050851:   "CRC32_authsession_bindAuthKeyUser",
	123258440:   "CRC32_authsession_unbindAuthKeyUser",
	-1871420202: "CRC32_authsession_getPermAuthKeyId",
	1620004742:  "CRC32_authsession_bindTempAuthKey",
	47841172:    "CRC32_authsession_setClientSessionInfo",
	1851660579:  "CRC32_authsession_getAuthorization",
	1331573041:  "CRC32_authsession_getAuthStateData",
}

var TLConstructor_value = map[string]int32{
	"CRC32_UNKNOWN":                          0,
	"CRC32_clientSession":                    -1701940816,
	"CRC32_authKeyStateData":                 -646863312,
	"CRC32_authsession_getAuthorizations":    820122180,
	"CRC32_authsession_resetAuthorization":   -1923126106,
	"CRC32_authsession_getLayer":             -1473309015,
	"CRC32_authsession_getLangPack":          700170598,
	"CRC32_authsession_getClient":            1616401854,
	"CRC32_authsession_getLangCode":          1486468441,
	"CRC32_authsession_getUserId":            1464409260,
	"CRC32_authsession_getPushSessionId":     -1279119039,
	"CRC32_authsession_getFutureSalts":       -1194371051,
	"CRC32_authsession_queryAuthKey":         1421293608,
	"CRC32_authsession_setAuthKey":           1049889937,
	"CRC32_authsession_bindAuthKeyUser":      198050851,
	"CRC32_authsession_unbindAuthKeyUser":    123258440,
	"CRC32_authsession_getPermAuthKeyId":     -1871420202,
	"CRC32_authsession_bindTempAuthKey":      1620004742,
	"CRC32_authsession_setClientSessionInfo": 47841172,
	"CRC32_authsession_getAuthorization":     1851660579,
	"CRC32_authsession_getAuthStateData":     1331573041,
}

func (x TLConstructor) String() string {
	return proto.EnumName(TLConstructor_name, int32(x))
}

func (TLConstructor) EnumDescriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{0}
}

//--------------------------------------------------------------------------------------------
// clientSession auth_key_id:long ip:string layer:int api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string proxy:string params:string = ClientSession;
//
// ClientSession <--
//  + TL_clientSession
//
type ClientSession struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Ip                   string        `protobuf:"bytes,4,opt,name=ip,proto3" json:"ip,omitempty"`
	Layer                int32         `protobuf:"varint,5,opt,name=layer,proto3" json:"layer,omitempty"`
	ApiId                int32         `protobuf:"varint,6,opt,name=api_id,json=apiId,proto3" json:"api_id,omitempty"`
	DeviceModel          string        `protobuf:"bytes,7,opt,name=device_model,json=deviceModel,proto3" json:"device_model,omitempty"`
	SystemVersion        string        `protobuf:"bytes,8,opt,name=system_version,json=systemVersion,proto3" json:"system_version,omitempty"`
	AppVersion           string        `protobuf:"bytes,9,opt,name=app_version,json=appVersion,proto3" json:"app_version,omitempty"`
	SystemLangCode       string        `protobuf:"bytes,10,opt,name=system_lang_code,json=systemLangCode,proto3" json:"system_lang_code,omitempty"`
	LangPack             string        `protobuf:"bytes,11,opt,name=lang_pack,json=langPack,proto3" json:"lang_pack,omitempty"`
	LangCode             string        `protobuf:"bytes,12,opt,name=lang_code,json=langCode,proto3" json:"lang_code,omitempty"`
	Proxy                string        `protobuf:"bytes,13,opt,name=proxy,proto3" json:"proxy,omitempty"`
	Params               string        `protobuf:"bytes,14,opt,name=params,proto3" json:"params,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *ClientSession) Reset()         { *m = ClientSession{} }
func (m *ClientSession) String() string { return proto.CompactTextString(m) }
func (*ClientSession) ProtoMessage()    {}
func (*ClientSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{0}
}
func (m *ClientSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *ClientSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_ClientSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *ClientSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_ClientSession.Merge(m, src)
}
func (m *ClientSession) XXX_Size() int {
	return m.Size()
}
func (m *ClientSession) XXX_DiscardUnknown() {
	xxx_messageInfo_ClientSession.DiscardUnknown(m)
}

var xxx_messageInfo_ClientSession proto.InternalMessageInfo

func (m *ClientSession) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *ClientSession) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *ClientSession) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *ClientSession) GetIp() string {
	if m != nil {
		return m.Ip
	}
	return ""
}

func (m *ClientSession) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *ClientSession) GetApiId() int32 {
	if m != nil {
		return m.ApiId
	}
	return 0
}

func (m *ClientSession) GetDeviceModel() string {
	if m != nil {
		return m.DeviceModel
	}
	return ""
}

func (m *ClientSession) GetSystemVersion() string {
	if m != nil {
		return m.SystemVersion
	}
	return ""
}

func (m *ClientSession) GetAppVersion() string {
	if m != nil {
		return m.AppVersion
	}
	return ""
}

func (m *ClientSession) GetSystemLangCode() string {
	if m != nil {
		return m.SystemLangCode
	}
	return ""
}

func (m *ClientSession) GetLangPack() string {
	if m != nil {
		return m.LangPack
	}
	return ""
}

func (m *ClientSession) GetLangCode() string {
	if m != nil {
		return m.LangCode
	}
	return ""
}

func (m *ClientSession) GetProxy() string {
	if m != nil {
		return m.Proxy
	}
	return ""
}

func (m *ClientSession) GetParams() string {
	if m != nil {
		return m.Params
	}
	return ""
}

// clientSession auth_key_id:long ip:string layer:int api_id:int device_model:string system_version:string app_version:string system_lang_code:string lang_pack:string lang_code:string proxy:string params:string = ClientSession;
type TLClientSession struct {
	Data2                *ClientSession `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLClientSession) Reset()         { *m = TLClientSession{} }
func (m *TLClientSession) String() string { return proto.CompactTextString(m) }
func (*TLClientSession) ProtoMessage()    {}
func (*TLClientSession) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{1}
}
func (m *TLClientSession) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLClientSession) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLClientSession.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLClientSession) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLClientSession.Merge(m, src)
}
func (m *TLClientSession) XXX_Size() int {
	return m.Size()
}
func (m *TLClientSession) XXX_DiscardUnknown() {
	xxx_messageInfo_TLClientSession.DiscardUnknown(m)
}

var xxx_messageInfo_TLClientSession proto.InternalMessageInfo

func (m *TLClientSession) GetData2() *ClientSession {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// authKeyStateData auth_key_id:long user_id:long key_state:int layer:int client_type:int android_push_session_id:long = AuthKeyStateData;
//
// AuthKeyStateData <--
//  + TL_authKeyStateData
//
type AuthKeyStateData struct {
	PredicateName        string        `protobuf:"bytes,1,opt,name=predicate_name,json=predicateName,proto3" json:"predicate_name,omitempty"`
	Constructor          TLConstructor `protobuf:"varint,2,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int64         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	KeyState             int32         `protobuf:"varint,5,opt,name=key_state,json=keyState,proto3" json:"key_state,omitempty"`
	Layer                int32         `protobuf:"varint,6,opt,name=layer,proto3" json:"layer,omitempty"`
	ClientType           int32         `protobuf:"varint,7,opt,name=client_type,json=clientType,proto3" json:"client_type,omitempty"`
	AndroidPushSessionId int64         `protobuf:"varint,8,opt,name=android_push_session_id,json=androidPushSessionId,proto3" json:"android_push_session_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *AuthKeyStateData) Reset()         { *m = AuthKeyStateData{} }
func (m *AuthKeyStateData) String() string { return proto.CompactTextString(m) }
func (*AuthKeyStateData) ProtoMessage()    {}
func (*AuthKeyStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{2}
}
func (m *AuthKeyStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *AuthKeyStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_AuthKeyStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *AuthKeyStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_AuthKeyStateData.Merge(m, src)
}
func (m *AuthKeyStateData) XXX_Size() int {
	return m.Size()
}
func (m *AuthKeyStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_AuthKeyStateData.DiscardUnknown(m)
}

var xxx_messageInfo_AuthKeyStateData proto.InternalMessageInfo

func (m *AuthKeyStateData) GetPredicateName() string {
	if m != nil {
		return m.PredicateName
	}
	return ""
}

func (m *AuthKeyStateData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *AuthKeyStateData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *AuthKeyStateData) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *AuthKeyStateData) GetKeyState() int32 {
	if m != nil {
		return m.KeyState
	}
	return 0
}

func (m *AuthKeyStateData) GetLayer() int32 {
	if m != nil {
		return m.Layer
	}
	return 0
}

func (m *AuthKeyStateData) GetClientType() int32 {
	if m != nil {
		return m.ClientType
	}
	return 0
}

func (m *AuthKeyStateData) GetAndroidPushSessionId() int64 {
	if m != nil {
		return m.AndroidPushSessionId
	}
	return 0
}

// authKeyStateData auth_key_id:long user_id:long key_state:int layer:int client_type:int android_push_session_id:long = AuthKeyStateData;
type TLAuthKeyStateData struct {
	Data2                *AuthKeyStateData `protobuf:"bytes,1,opt,name=data2,proto3" json:"data2,omitempty"`
	XXX_NoUnkeyedLiteral struct{}          `json:"-"`
	XXX_unrecognized     []byte            `json:"-"`
	XXX_sizecache        int32             `json:"-"`
}

func (m *TLAuthKeyStateData) Reset()         { *m = TLAuthKeyStateData{} }
func (m *TLAuthKeyStateData) String() string { return proto.CompactTextString(m) }
func (*TLAuthKeyStateData) ProtoMessage()    {}
func (*TLAuthKeyStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{3}
}
func (m *TLAuthKeyStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthKeyStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthKeyStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthKeyStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthKeyStateData.Merge(m, src)
}
func (m *TLAuthKeyStateData) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthKeyStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthKeyStateData.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthKeyStateData proto.InternalMessageInfo

func (m *TLAuthKeyStateData) GetData2() *AuthKeyStateData {
	if m != nil {
		return m.Data2
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// authsession.getAuthorizations user_id:long exclude_auth_keyId:long = account.Authorizations;
type TLAuthsessionGetAuthorizations struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	ExcludeAuthKeyId     int64         `protobuf:"varint,4,opt,name=exclude_auth_keyId,json=excludeAuthKeyId,proto3" json:"exclude_auth_keyId,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetAuthorizations) Reset()         { *m = TLAuthsessionGetAuthorizations{} }
func (m *TLAuthsessionGetAuthorizations) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetAuthorizations) ProtoMessage()    {}
func (*TLAuthsessionGetAuthorizations) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{4}
}
func (m *TLAuthsessionGetAuthorizations) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetAuthorizations) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetAuthorizations.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetAuthorizations) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetAuthorizations.Merge(m, src)
}
func (m *TLAuthsessionGetAuthorizations) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetAuthorizations) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetAuthorizations.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetAuthorizations proto.InternalMessageInfo

func (m *TLAuthsessionGetAuthorizations) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetAuthorizations) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLAuthsessionGetAuthorizations) GetExcludeAuthKeyId() int64 {
	if m != nil {
		return m.ExcludeAuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.resetAuthorization user_id:long auth_key_id:long hash:long = Vector<long>;
type TLAuthsessionResetAuthorization struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Hash                 int64         `protobuf:"varint,5,opt,name=hash,proto3" json:"hash,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionResetAuthorization) Reset()         { *m = TLAuthsessionResetAuthorization{} }
func (m *TLAuthsessionResetAuthorization) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionResetAuthorization) ProtoMessage()    {}
func (*TLAuthsessionResetAuthorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{5}
}
func (m *TLAuthsessionResetAuthorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionResetAuthorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionResetAuthorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionResetAuthorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionResetAuthorization.Merge(m, src)
}
func (m *TLAuthsessionResetAuthorization) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionResetAuthorization) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionResetAuthorization.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionResetAuthorization proto.InternalMessageInfo

func (m *TLAuthsessionResetAuthorization) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionResetAuthorization) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLAuthsessionResetAuthorization) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionResetAuthorization) GetHash() int64 {
	if m != nil {
		return m.Hash
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getLayer auth_key_id:long = Int32;
type TLAuthsessionGetLayer struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetLayer) Reset()         { *m = TLAuthsessionGetLayer{} }
func (m *TLAuthsessionGetLayer) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetLayer) ProtoMessage()    {}
func (*TLAuthsessionGetLayer) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{6}
}
func (m *TLAuthsessionGetLayer) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetLayer) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetLayer.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetLayer) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetLayer.Merge(m, src)
}
func (m *TLAuthsessionGetLayer) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetLayer) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetLayer.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetLayer proto.InternalMessageInfo

func (m *TLAuthsessionGetLayer) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetLayer) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getLangPack auth_key_id:long = String;
type TLAuthsessionGetLangPack struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetLangPack) Reset()         { *m = TLAuthsessionGetLangPack{} }
func (m *TLAuthsessionGetLangPack) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetLangPack) ProtoMessage()    {}
func (*TLAuthsessionGetLangPack) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{7}
}
func (m *TLAuthsessionGetLangPack) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetLangPack) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetLangPack.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetLangPack) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetLangPack.Merge(m, src)
}
func (m *TLAuthsessionGetLangPack) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetLangPack) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetLangPack.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetLangPack proto.InternalMessageInfo

func (m *TLAuthsessionGetLangPack) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetLangPack) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getClient auth_key_id:long = String;
type TLAuthsessionGetClient struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetClient) Reset()         { *m = TLAuthsessionGetClient{} }
func (m *TLAuthsessionGetClient) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetClient) ProtoMessage()    {}
func (*TLAuthsessionGetClient) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{8}
}
func (m *TLAuthsessionGetClient) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetClient) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetClient.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetClient) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetClient.Merge(m, src)
}
func (m *TLAuthsessionGetClient) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetClient) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetClient.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetClient proto.InternalMessageInfo

func (m *TLAuthsessionGetClient) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetClient) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getLangCode auth_key_id:long = String;
type TLAuthsessionGetLangCode struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetLangCode) Reset()         { *m = TLAuthsessionGetLangCode{} }
func (m *TLAuthsessionGetLangCode) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetLangCode) ProtoMessage()    {}
func (*TLAuthsessionGetLangCode) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{9}
}
func (m *TLAuthsessionGetLangCode) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetLangCode) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetLangCode.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetLangCode) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetLangCode.Merge(m, src)
}
func (m *TLAuthsessionGetLangCode) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetLangCode) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetLangCode.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetLangCode proto.InternalMessageInfo

func (m *TLAuthsessionGetLangCode) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetLangCode) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getUserId auth_key_id:long = Int64;
type TLAuthsessionGetUserId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetUserId) Reset()         { *m = TLAuthsessionGetUserId{} }
func (m *TLAuthsessionGetUserId) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetUserId) ProtoMessage()    {}
func (*TLAuthsessionGetUserId) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{10}
}
func (m *TLAuthsessionGetUserId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetUserId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetUserId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetUserId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetUserId.Merge(m, src)
}
func (m *TLAuthsessionGetUserId) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetUserId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetUserId.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetUserId proto.InternalMessageInfo

func (m *TLAuthsessionGetUserId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetUserId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getPushSessionId user_id:long auth_key_id:long token_type:int = Int64;
type TLAuthsessionGetPushSessionId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	UserId               int64         `protobuf:"varint,3,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,4,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	TokenType            int32         `protobuf:"varint,5,opt,name=token_type,json=tokenType,proto3" json:"token_type,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetPushSessionId) Reset()         { *m = TLAuthsessionGetPushSessionId{} }
func (m *TLAuthsessionGetPushSessionId) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetPushSessionId) ProtoMessage()    {}
func (*TLAuthsessionGetPushSessionId) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{11}
}
func (m *TLAuthsessionGetPushSessionId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetPushSessionId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetPushSessionId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetPushSessionId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetPushSessionId.Merge(m, src)
}
func (m *TLAuthsessionGetPushSessionId) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetPushSessionId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetPushSessionId.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetPushSessionId proto.InternalMessageInfo

func (m *TLAuthsessionGetPushSessionId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetPushSessionId) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

func (m *TLAuthsessionGetPushSessionId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionGetPushSessionId) GetTokenType() int32 {
	if m != nil {
		return m.TokenType
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getFutureSalts auth_key_id:long num:int = FutureSalts;
type TLAuthsessionGetFutureSalts struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	Num                  int32         `protobuf:"varint,4,opt,name=num,proto3" json:"num,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetFutureSalts) Reset()         { *m = TLAuthsessionGetFutureSalts{} }
func (m *TLAuthsessionGetFutureSalts) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetFutureSalts) ProtoMessage()    {}
func (*TLAuthsessionGetFutureSalts) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{12}
}
func (m *TLAuthsessionGetFutureSalts) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetFutureSalts) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetFutureSalts.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetFutureSalts) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetFutureSalts.Merge(m, src)
}
func (m *TLAuthsessionGetFutureSalts) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetFutureSalts) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetFutureSalts.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetFutureSalts proto.InternalMessageInfo

func (m *TLAuthsessionGetFutureSalts) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetFutureSalts) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionGetFutureSalts) GetNum() int32 {
	if m != nil {
		return m.Num
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.queryAuthKey auth_key_id:long = AuthKeyInfo;
type TLAuthsessionQueryAuthKey struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionQueryAuthKey) Reset()         { *m = TLAuthsessionQueryAuthKey{} }
func (m *TLAuthsessionQueryAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionQueryAuthKey) ProtoMessage()    {}
func (*TLAuthsessionQueryAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{13}
}
func (m *TLAuthsessionQueryAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionQueryAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionQueryAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionQueryAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionQueryAuthKey.Merge(m, src)
}
func (m *TLAuthsessionQueryAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionQueryAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionQueryAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionQueryAuthKey proto.InternalMessageInfo

func (m *TLAuthsessionQueryAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionQueryAuthKey) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.setAuthKey auth_key:AuthKeyInfo future_salt:FutureSalt expires_in:int = Bool;
type TLAuthsessionSetAuthKey struct {
	Constructor          TLConstructor        `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKey              *mtproto.AuthKeyInfo `protobuf:"bytes,3,opt,name=auth_key,json=authKey,proto3" json:"auth_key,omitempty"`
	FutureSalt           *mtproto.FutureSalt  `protobuf:"bytes,4,opt,name=future_salt,json=futureSalt,proto3" json:"future_salt,omitempty"`
	ExpiresIn            int32                `protobuf:"varint,5,opt,name=expires_in,json=expiresIn,proto3" json:"expires_in,omitempty"`
	XXX_NoUnkeyedLiteral struct{}             `json:"-"`
	XXX_unrecognized     []byte               `json:"-"`
	XXX_sizecache        int32                `json:"-"`
}

func (m *TLAuthsessionSetAuthKey) Reset()         { *m = TLAuthsessionSetAuthKey{} }
func (m *TLAuthsessionSetAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionSetAuthKey) ProtoMessage()    {}
func (*TLAuthsessionSetAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{14}
}
func (m *TLAuthsessionSetAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionSetAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionSetAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionSetAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionSetAuthKey.Merge(m, src)
}
func (m *TLAuthsessionSetAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionSetAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionSetAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionSetAuthKey proto.InternalMessageInfo

func (m *TLAuthsessionSetAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionSetAuthKey) GetAuthKey() *mtproto.AuthKeyInfo {
	if m != nil {
		return m.AuthKey
	}
	return nil
}

func (m *TLAuthsessionSetAuthKey) GetFutureSalt() *mtproto.FutureSalt {
	if m != nil {
		return m.FutureSalt
	}
	return nil
}

func (m *TLAuthsessionSetAuthKey) GetExpiresIn() int32 {
	if m != nil {
		return m.ExpiresIn
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.bindAuthKeyUser auth_key_id:long user_id:long = Int64;
type TLAuthsessionBindAuthKeyUser struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int64         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionBindAuthKeyUser) Reset()         { *m = TLAuthsessionBindAuthKeyUser{} }
func (m *TLAuthsessionBindAuthKeyUser) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionBindAuthKeyUser) ProtoMessage()    {}
func (*TLAuthsessionBindAuthKeyUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{15}
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionBindAuthKeyUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionBindAuthKeyUser.Merge(m, src)
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionBindAuthKeyUser) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionBindAuthKeyUser.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionBindAuthKeyUser proto.InternalMessageInfo

func (m *TLAuthsessionBindAuthKeyUser) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionBindAuthKeyUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionBindAuthKeyUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.unbindAuthKeyUser auth_key_id:long user_id:long = Bool;
type TLAuthsessionUnbindAuthKeyUser struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	UserId               int64         `protobuf:"varint,4,opt,name=user_id,json=userId,proto3" json:"user_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionUnbindAuthKeyUser) Reset()         { *m = TLAuthsessionUnbindAuthKeyUser{} }
func (m *TLAuthsessionUnbindAuthKeyUser) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionUnbindAuthKeyUser) ProtoMessage()    {}
func (*TLAuthsessionUnbindAuthKeyUser) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{16}
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser.Merge(m, src)
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionUnbindAuthKeyUser) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionUnbindAuthKeyUser proto.InternalMessageInfo

func (m *TLAuthsessionUnbindAuthKeyUser) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionUnbindAuthKeyUser) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

func (m *TLAuthsessionUnbindAuthKeyUser) GetUserId() int64 {
	if m != nil {
		return m.UserId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getPermAuthKeyId auth_key_id:long= Int64;
type TLAuthsessionGetPermAuthKeyId struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetPermAuthKeyId) Reset()         { *m = TLAuthsessionGetPermAuthKeyId{} }
func (m *TLAuthsessionGetPermAuthKeyId) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetPermAuthKeyId) ProtoMessage()    {}
func (*TLAuthsessionGetPermAuthKeyId) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{17}
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetPermAuthKeyId.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetPermAuthKeyId.Merge(m, src)
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetPermAuthKeyId) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetPermAuthKeyId.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetPermAuthKeyId proto.InternalMessageInfo

func (m *TLAuthsessionGetPermAuthKeyId) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetPermAuthKeyId) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.bindTempAuthKey perm_auth_key_id:long nonce:long expires_at:int encrypted_message:bytes = Bool;
type TLAuthsessionBindTempAuthKey struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	PermAuthKeyId        int64         `protobuf:"varint,3,opt,name=perm_auth_key_id,json=permAuthKeyId,proto3" json:"perm_auth_key_id,omitempty"`
	Nonce                int64         `protobuf:"varint,4,opt,name=nonce,proto3" json:"nonce,omitempty"`
	ExpiresAt            int32         `protobuf:"varint,5,opt,name=expires_at,json=expiresAt,proto3" json:"expires_at,omitempty"`
	EncryptedMessage     []byte        `protobuf:"bytes,6,opt,name=encrypted_message,json=encryptedMessage,proto3" json:"encrypted_message,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionBindTempAuthKey) Reset()         { *m = TLAuthsessionBindTempAuthKey{} }
func (m *TLAuthsessionBindTempAuthKey) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionBindTempAuthKey) ProtoMessage()    {}
func (*TLAuthsessionBindTempAuthKey) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{18}
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionBindTempAuthKey.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionBindTempAuthKey.Merge(m, src)
}
func (m *TLAuthsessionBindTempAuthKey) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionBindTempAuthKey) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionBindTempAuthKey.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionBindTempAuthKey proto.InternalMessageInfo

func (m *TLAuthsessionBindTempAuthKey) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionBindTempAuthKey) GetPermAuthKeyId() int64 {
	if m != nil {
		return m.PermAuthKeyId
	}
	return 0
}

func (m *TLAuthsessionBindTempAuthKey) GetNonce() int64 {
	if m != nil {
		return m.Nonce
	}
	return 0
}

func (m *TLAuthsessionBindTempAuthKey) GetExpiresAt() int32 {
	if m != nil {
		return m.ExpiresAt
	}
	return 0
}

func (m *TLAuthsessionBindTempAuthKey) GetEncryptedMessage() []byte {
	if m != nil {
		return m.EncryptedMessage
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// authsession.setClientSessionInfo data:ClientSession = Bool;
type TLAuthsessionSetClientSessionInfo struct {
	Constructor          TLConstructor  `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	Data                 *ClientSession `protobuf:"bytes,3,opt,name=data,proto3" json:"data,omitempty"`
	XXX_NoUnkeyedLiteral struct{}       `json:"-"`
	XXX_unrecognized     []byte         `json:"-"`
	XXX_sizecache        int32          `json:"-"`
}

func (m *TLAuthsessionSetClientSessionInfo) Reset()         { *m = TLAuthsessionSetClientSessionInfo{} }
func (m *TLAuthsessionSetClientSessionInfo) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionSetClientSessionInfo) ProtoMessage()    {}
func (*TLAuthsessionSetClientSessionInfo) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{19}
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionSetClientSessionInfo.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionSetClientSessionInfo.Merge(m, src)
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionSetClientSessionInfo) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionSetClientSessionInfo.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionSetClientSessionInfo proto.InternalMessageInfo

func (m *TLAuthsessionSetClientSessionInfo) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionSetClientSessionInfo) GetData() *ClientSession {
	if m != nil {
		return m.Data
	}
	return nil
}

//--------------------------------------------------------------------------------------------
// authsession.getAuthorization auth_key_id:long = Authorization;
type TLAuthsessionGetAuthorization struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetAuthorization) Reset()         { *m = TLAuthsessionGetAuthorization{} }
func (m *TLAuthsessionGetAuthorization) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetAuthorization) ProtoMessage()    {}
func (*TLAuthsessionGetAuthorization) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{20}
}
func (m *TLAuthsessionGetAuthorization) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetAuthorization) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetAuthorization.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetAuthorization) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetAuthorization.Merge(m, src)
}
func (m *TLAuthsessionGetAuthorization) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetAuthorization) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetAuthorization.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetAuthorization proto.InternalMessageInfo

func (m *TLAuthsessionGetAuthorization) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetAuthorization) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// authsession.getAuthStateData auth_key_id:long = AuthKeyStateData;
type TLAuthsessionGetAuthStateData struct {
	Constructor          TLConstructor `protobuf:"varint,1,opt,name=constructor,proto3,enum=authsession.TLConstructor" json:"constructor,omitempty"`
	AuthKeyId            int64         `protobuf:"varint,3,opt,name=auth_key_id,json=authKeyId,proto3" json:"auth_key_id,omitempty"`
	XXX_NoUnkeyedLiteral struct{}      `json:"-"`
	XXX_unrecognized     []byte        `json:"-"`
	XXX_sizecache        int32         `json:"-"`
}

func (m *TLAuthsessionGetAuthStateData) Reset()         { *m = TLAuthsessionGetAuthStateData{} }
func (m *TLAuthsessionGetAuthStateData) String() string { return proto.CompactTextString(m) }
func (*TLAuthsessionGetAuthStateData) ProtoMessage()    {}
func (*TLAuthsessionGetAuthStateData) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{21}
}
func (m *TLAuthsessionGetAuthStateData) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *TLAuthsessionGetAuthStateData) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_TLAuthsessionGetAuthStateData.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *TLAuthsessionGetAuthStateData) XXX_Merge(src proto.Message) {
	xxx_messageInfo_TLAuthsessionGetAuthStateData.Merge(m, src)
}
func (m *TLAuthsessionGetAuthStateData) XXX_Size() int {
	return m.Size()
}
func (m *TLAuthsessionGetAuthStateData) XXX_DiscardUnknown() {
	xxx_messageInfo_TLAuthsessionGetAuthStateData.DiscardUnknown(m)
}

var xxx_messageInfo_TLAuthsessionGetAuthStateData proto.InternalMessageInfo

func (m *TLAuthsessionGetAuthStateData) GetConstructor() TLConstructor {
	if m != nil {
		return m.Constructor
	}
	return CRC32_UNKNOWN
}

func (m *TLAuthsessionGetAuthStateData) GetAuthKeyId() int64 {
	if m != nil {
		return m.AuthKeyId
	}
	return 0
}

//--------------------------------------------------------------------------------------------
// Vector api result type
type Vector_Long struct {
	Datas                []int64  `protobuf:"varint,1,rep,packed,name=datas,proto3" json:"datas,omitempty"`
	XXX_NoUnkeyedLiteral struct{} `json:"-"`
	XXX_unrecognized     []byte   `json:"-"`
	XXX_sizecache        int32    `json:"-"`
}

func (m *Vector_Long) Reset()         { *m = Vector_Long{} }
func (m *Vector_Long) String() string { return proto.CompactTextString(m) }
func (*Vector_Long) ProtoMessage()    {}
func (*Vector_Long) Descriptor() ([]byte, []int) {
	return fileDescriptor_7cbc1347c4a76ecf, []int{22}
}
func (m *Vector_Long) XXX_Unmarshal(b []byte) error {
	return m.Unmarshal(b)
}
func (m *Vector_Long) XXX_Marshal(b []byte, deterministic bool) ([]byte, error) {
	if deterministic {
		return xxx_messageInfo_Vector_Long.Marshal(b, m, deterministic)
	} else {
		b = b[:cap(b)]
		n, err := m.MarshalToSizedBuffer(b)
		if err != nil {
			return nil, err
		}
		return b[:n], nil
	}
}
func (m *Vector_Long) XXX_Merge(src proto.Message) {
	xxx_messageInfo_Vector_Long.Merge(m, src)
}
func (m *Vector_Long) XXX_Size() int {
	return m.Size()
}
func (m *Vector_Long) XXX_DiscardUnknown() {
	xxx_messageInfo_Vector_Long.DiscardUnknown(m)
}

var xxx_messageInfo_Vector_Long proto.InternalMessageInfo

func (m *Vector_Long) GetDatas() []int64 {
	if m != nil {
		return m.Datas
	}
	return nil
}

func init() {
	proto.RegisterEnum("authsession.TLConstructor", TLConstructor_name, TLConstructor_value)
	proto.RegisterType((*ClientSession)(nil), "authsession.ClientSession")
	proto.RegisterType((*TLClientSession)(nil), "authsession.TL_clientSession")
	proto.RegisterType((*AuthKeyStateData)(nil), "authsession.AuthKeyStateData")
	proto.RegisterType((*TLAuthKeyStateData)(nil), "authsession.TL_authKeyStateData")
	proto.RegisterType((*TLAuthsessionGetAuthorizations)(nil), "authsession.TL_authsession_getAuthorizations")
	proto.RegisterType((*TLAuthsessionResetAuthorization)(nil), "authsession.TL_authsession_resetAuthorization")
	proto.RegisterType((*TLAuthsessionGetLayer)(nil), "authsession.TL_authsession_getLayer")
	proto.RegisterType((*TLAuthsessionGetLangPack)(nil), "authsession.TL_authsession_getLangPack")
	proto.RegisterType((*TLAuthsessionGetClient)(nil), "authsession.TL_authsession_getClient")
	proto.RegisterType((*TLAuthsessionGetLangCode)(nil), "authsession.TL_authsession_getLangCode")
	proto.RegisterType((*TLAuthsessionGetUserId)(nil), "authsession.TL_authsession_getUserId")
	proto.RegisterType((*TLAuthsessionGetPushSessionId)(nil), "authsession.TL_authsession_getPushSessionId")
	proto.RegisterType((*TLAuthsessionGetFutureSalts)(nil), "authsession.TL_authsession_getFutureSalts")
	proto.RegisterType((*TLAuthsessionQueryAuthKey)(nil), "authsession.TL_authsession_queryAuthKey")
	proto.RegisterType((*TLAuthsessionSetAuthKey)(nil), "authsession.TL_authsession_setAuthKey")
	proto.RegisterType((*TLAuthsessionBindAuthKeyUser)(nil), "authsession.TL_authsession_bindAuthKeyUser")
	proto.RegisterType((*TLAuthsessionUnbindAuthKeyUser)(nil), "authsession.TL_authsession_unbindAuthKeyUser")
	proto.RegisterType((*TLAuthsessionGetPermAuthKeyId)(nil), "authsession.TL_authsession_getPermAuthKeyId")
	proto.RegisterType((*TLAuthsessionBindTempAuthKey)(nil), "authsession.TL_authsession_bindTempAuthKey")
	proto.RegisterType((*TLAuthsessionSetClientSessionInfo)(nil), "authsession.TL_authsession_setClientSessionInfo")
	proto.RegisterType((*TLAuthsessionGetAuthorization)(nil), "authsession.TL_authsession_getAuthorization")
	proto.RegisterType((*TLAuthsessionGetAuthStateData)(nil), "authsession.TL_authsession_getAuthStateData")
	proto.RegisterType((*Vector_Long)(nil), "authsession.Vector_Long")
}

func init() { proto.RegisterFile("authsession.tl.proto", fileDescriptor_7cbc1347c4a76ecf) }

var fileDescriptor_7cbc1347c4a76ecf = []byte{
	// 1734 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xcc, 0x58, 0x5d, 0x6c, 0x1b, 0x59,
	0x15, 0xf6, 0xc4, 0xb1, 0x9b, 0x1c, 0xd7, 0x61, 0xf6, 0xd6, 0x9b, 0x78, 0x27, 0x1b, 0xc7, 0x9d,
	0xf4, 0x27, 0xa4, 0x8d, 0xbd, 0x24, 0x0b, 0x0f, 0x08, 0x09, 0x65, 0xb3, 0x42, 0x32, 0x9b, 0x0d,
	0x59, 0x27, 0x5d, 0x24, 0x40, 0x3b, 0xdc, 0xcc, 0xdc, 0x38, 0xa3, 0x78, 0x7e, 0x76, 0x66, 0xdc,
	0x8d, 0x97, 0x07, 0xa4, 0x05, 0x41, 0x1e, 0x90, 0x10, 0x02, 0x84, 0xf6, 0x05, 0x1e, 0xba, 0xfc,
	0x89, 0x1f, 0x15, 0x5e, 0x60, 0x81, 0x22, 0x55, 0xaa, 0xaa, 0x22, 0x7e, 0x54, 0x24, 0x84, 0x54,
	0x09, 0x09, 0x9a, 0x4a, 0x45, 0xf4, 0x85, 0x0a, 0x21, 0x51, 0x8a, 0xaa, 0xa0, 0xb9, 0x77, 0x6c,
	0xcf, 0x9f, 0xed, 0x56, 0xad, 0xd5, 0xbe, 0xcd, 0x3d, 0xf7, 0xbb, 0xe7, 0x7c, 0xf7, 0x9c, 0x73,
	0xcf, 0x3d, 0x77, 0x20, 0x87, 0x1b, 0xce, 0xb6, 0x4d, 0x6c, 0x5b, 0x35, 0xf4, 0x92, 0x53, 0x2f,
	0x99, 0x96, 0xe1, 0x18, 0x28, 0xe3, 0x93, 0x0a, 0xf3, 0x35, 0xd5, 0xd9, 0x6e, 0x6c, 0x96, 0x64,
	0x43, 0x2b, 0xd7, 0x8c, 0x9a, 0x51, 0xa6, 0x98, 0xcd, 0xc6, 0x16, 0x1d, 0xd1, 0x01, 0xfd, 0x62,
	0x6b, 0x85, 0x42, 0xcd, 0x30, 0x6a, 0x75, 0xd2, 0x41, 0xbd, 0x61, 0x61, 0xd3, 0x24, 0x96, 0xed,
	0xcd, 0x0b, 0xb6, 0xbc, 0x4d, 0x34, 0xec, 0x1a, 0x93, 0x0d, 0x8b, 0x48, 0x4e, 0xd3, 0x24, 0xad,
	0xb9, 0x67, 0x3a, 0x73, 0x8e, 0x85, 0x75, 0xdb, 0x34, 0x2c, 0xc7, 0x9b, 0xca, 0x75, 0xa6, 0xec,
	0xa6, 0x2e, 0x33, 0xa9, 0xf8, 0x87, 0x24, 0x64, 0x97, 0xeb, 0x2a, 0xd1, 0x9d, 0x75, 0xc6, 0x16,
	0x1d, 0x87, 0x31, 0xd3, 0x22, 0x8a, 0x2a, 0x63, 0x87, 0x48, 0x3a, 0xd6, 0x48, 0x9e, 0x2b, 0x72,
	0xb3, 0xa3, 0xd5, 0x6c, 0x5b, 0xba, 0x8a, 0x35, 0x82, 0x3e, 0x04, 0x19, 0xd9, 0xd0, 0x6d, 0xc7,
	0x6a, 0xc8, 0x8e, 0x61, 0xe5, 0x87, 0x8a, 0xdc, 0xec, 0xd8, 0x82, 0x50, 0xf2, 0x7b, 0x63, 0x63,
	0x65, 0xb9, 0x83, 0xa8, 0xfa, 0xe1, 0xa8, 0x00, 0xd4, 0x43, 0xd2, 0x0e, 0x69, 0x4a, 0xaa, 0x92,
	0x4f, 0x16, 0xb9, 0xd9, 0x64, 0x75, 0xd4, 0x15, 0xbd, 0x44, 0x9a, 0x15, 0x05, 0x8d, 0xc1, 0x90,
	0x6a, 0xe6, 0x87, 0xa9, 0xe1, 0x21, 0xd5, 0x44, 0x39, 0x48, 0xd5, 0x71, 0x93, 0x58, 0xf9, 0x54,
	0x91, 0x9b, 0x4d, 0x55, 0xd9, 0x00, 0x3d, 0x0d, 0x69, 0x6c, 0xaa, 0xae, 0x82, 0x34, 0x13, 0x63,
	0x53, 0xad, 0x28, 0xe8, 0x28, 0x1c, 0x56, 0xc8, 0x59, 0x55, 0x26, 0x92, 0x66, 0x28, 0xa4, 0x9e,
	0x3f, 0x44, 0xd5, 0x64, 0x98, 0xec, 0x65, 0x57, 0xe4, 0x6e, 0xd2, 0x6e, 0xda, 0x0e, 0xd1, 0xa4,
	0xb3, 0xc4, 0x72, 0xc9, 0xe6, 0x47, 0xd8, 0x26, 0x99, 0xf4, 0x55, 0x26, 0x44, 0xd3, 0x90, 0xc1,
	0xa6, 0xd9, 0xc6, 0x8c, 0x52, 0x0c, 0x60, 0xd3, 0x6c, 0x01, 0x66, 0x81, 0xf7, 0xf4, 0xd4, 0xb1,
	0x5e, 0x93, 0x64, 0x43, 0x21, 0x79, 0xa0, 0x28, 0x4f, 0xff, 0x0a, 0xd6, 0x6b, 0xcb, 0x86, 0x42,
	0xd0, 0x24, 0x8c, 0x52, 0x88, 0x89, 0xe5, 0x9d, 0x7c, 0x86, 0x42, 0x46, 0x5c, 0xc1, 0x1a, 0x96,
	0x77, 0xda, 0x93, 0x74, 0xfd, 0xe1, 0xce, 0x24, 0x5d, 0x99, 0x83, 0x94, 0x69, 0x19, 0xbb, 0xcd,
	0x7c, 0x96, 0x4e, 0xb0, 0x01, 0x1a, 0x87, 0xb4, 0x89, 0x2d, 0xac, 0xd9, 0xf9, 0x31, 0x2a, 0xf6,
	0x46, 0xe2, 0x8b, 0xc0, 0x6f, 0xac, 0x48, 0x72, 0x20, 0xa4, 0xcf, 0x41, 0x4a, 0xc1, 0x0e, 0x5e,
	0xa0, 0x91, 0xcc, 0x84, 0xa2, 0x14, 0x88, 0x7e, 0x95, 0x01, 0xc5, 0x5f, 0x0e, 0x01, 0xbf, 0xc4,
	0xa2, 0xb1, 0xee, 0x60, 0x87, 0xbc, 0x88, 0x1d, 0xfc, 0x64, 0x64, 0xc6, 0x04, 0x1c, 0x6a, 0xd8,
	0xc4, 0x72, 0xe7, 0x86, 0xe9, 0x5c, 0xda, 0x1d, 0x56, 0x14, 0xd7, 0x87, 0xee, 0x1a, 0xdb, 0xa5,
	0xeb, 0xa5, 0xc9, 0xc8, 0x8e, 0x47, 0xbf, 0x93, 0x3f, 0x69, 0x7f, 0xfe, 0x4c, 0x43, 0x86, 0x39,
	0x8a, 0x9e, 0x21, 0x9a, 0x27, 0xa9, 0x2a, 0x30, 0xd1, 0x46, 0xd3, 0x24, 0xe8, 0xfd, 0x30, 0x81,
	0x75, 0xc5, 0x32, 0x54, 0x45, 0x32, 0x1b, 0xf6, 0xb6, 0xe4, 0xf1, 0x77, 0x8d, 0x8f, 0x50, 0xe3,
	0x39, 0x6f, 0x7a, 0xad, 0x61, 0x6f, 0x7b, 0x2e, 0xac, 0x28, 0xe2, 0x47, 0xe1, 0xc8, 0xc6, 0x8a,
	0x84, 0xc3, 0xfe, 0x5b, 0x0c, 0x86, 0x61, 0x2a, 0xe0, 0x92, 0xb0, 0xb7, 0x5b, 0x91, 0xf8, 0x2e,
	0x07, 0x45, 0x4f, 0x59, 0xcb, 0x7a, 0x8d, 0x38, 0x2e, 0xda, 0xb0, 0xd4, 0x37, 0xb1, 0xa3, 0x1a,
	0xba, 0x1d, 0x76, 0x39, 0xf7, 0x60, 0x2e, 0xf7, 0xb9, 0x34, 0x19, 0x70, 0xe9, 0x69, 0x40, 0x64,
	0x57, 0xae, 0x37, 0x14, 0x22, 0xb5, 0x62, 0x52, 0x69, 0xb9, 0x9d, 0xf7, 0x66, 0x96, 0x5a, 0x91,
	0x11, 0x7f, 0xcc, 0xc1, 0xd1, 0x10, 0x53, 0x8b, 0xd8, 0x21, 0xae, 0x83, 0xa2, 0x1a, 0x4a, 0x9b,
	0xe1, 0x70, 0xda, 0x20, 0x18, 0xde, 0xc6, 0xf6, 0x36, 0x4d, 0x8c, 0x64, 0x95, 0x7e, 0x8b, 0x6f,
	0xc0, 0x44, 0xd4, 0xb3, 0x2b, 0x34, 0x33, 0x1e, 0x8e, 0x65, 0x9f, 0x1c, 0x16, 0xdf, 0x04, 0x21,
	0xce, 0xb0, 0x57, 0x0c, 0x06, 0x6b, 0x7b, 0x17, 0xf2, 0x51, 0xdb, 0xac, 0x06, 0x3c, 0xae, 0x5d,
	0xd3, 0x2a, 0xf7, 0x18, 0x76, 0x7d, 0x86, 0xa5, 0xce, 0x60, 0x2d, 0xff, 0x8c, 0x83, 0xe9, 0xa8,
	0xe9, 0x40, 0xbd, 0x78, 0x5c, 0x67, 0x62, 0x0a, 0xc0, 0x31, 0x76, 0x88, 0xce, 0xaa, 0x1f, 0x2b,
	0x99, 0xa3, 0x54, 0xe2, 0x16, 0x3f, 0xf1, 0xcb, 0x1c, 0x4c, 0x45, 0x99, 0x7f, 0xa4, 0xe1, 0x34,
	0x2c, 0xb2, 0x8e, 0xeb, 0x8e, 0x3d, 0x58, 0xcf, 0x21, 0x1e, 0x92, 0x7a, 0x43, 0xa3, 0xb4, 0x53,
	0x55, 0xf7, 0x53, 0xfc, 0x0c, 0x4c, 0x86, 0x08, 0xbd, 0xde, 0x20, 0x56, 0xd3, 0x2b, 0x41, 0x03,
	0x0e, 0xe4, 0x5f, 0x39, 0x78, 0x26, 0x64, 0xdd, 0x2b, 0x6e, 0x0f, 0x6f, 0xbb, 0x0c, 0x23, 0x2d,
	0xdb, 0xd4, 0x70, 0x66, 0x21, 0x57, 0xd2, 0x1c, 0xda, 0xa1, 0xb5, 0x2e, 0x86, 0x8a, 0xbe, 0x65,
	0x54, 0x0f, 0x79, 0x74, 0xd0, 0xf3, 0x90, 0xd9, 0xa2, 0x81, 0x90, 0x6c, 0x5c, 0x77, 0xa8, 0x8f,
	0x32, 0x0b, 0x47, 0xda, 0x6b, 0x3a, 0x41, 0xaa, 0xc2, 0x56, 0xfb, 0xdb, 0x0d, 0x38, 0xd9, 0x35,
	0x55, 0x8b, 0xd8, 0x92, 0xaa, 0xb7, 0x02, 0xee, 0x49, 0x2a, 0xba, 0xf8, 0x0d, 0x0e, 0x0a, 0xa1,
	0x1d, 0x6e, 0xaa, 0xba, 0xe2, 0x11, 0x70, 0x4f, 0xcb, 0x80, 0x23, 0xde, 0xed, 0x6e, 0x17, 0xdf,
	0x8e, 0x5e, 0x82, 0x0d, 0xfd, 0x09, 0xe1, 0xf6, 0xd9, 0xd8, 0xf3, 0x4d, 0x2c, 0xad, 0x7d, 0x33,
	0x0e, 0x38, 0x31, 0xff, 0x11, 0x1f, 0xb6, 0x0d, 0xa2, 0x99, 0x8f, 0x26, 0x3b, 0x4f, 0x02, 0x6f,
	0x12, 0x4b, 0x93, 0xa2, 0x2c, 0xb2, 0x66, 0x60, 0x9f, 0x39, 0x48, 0xe9, 0x86, 0x2e, 0x13, 0xcf,
	0x43, 0x6c, 0xe0, 0xcf, 0x3a, 0xec, 0x84, 0xb2, 0x6e, 0xc9, 0x41, 0xa7, 0xe0, 0x29, 0xa2, 0xcb,
	0x56, 0xd3, 0x74, 0x88, 0x22, 0x69, 0xc4, 0xb6, 0x71, 0x8d, 0xd0, 0x36, 0xed, 0x70, 0x95, 0x6f,
	0x4f, 0xbc, 0xcc, 0xe4, 0xe2, 0x57, 0x39, 0x98, 0x89, 0x1e, 0xc2, 0x40, 0x0b, 0xeb, 0x1e, 0x94,
	0x87, 0xdc, 0x70, 0x09, 0x86, 0xdd, 0xe6, 0xcb, 0x3b, 0x8a, 0xbd, 0xda, 0x65, 0x8a, 0x8b, 0x4f,
	0x81, 0x47, 0xd9, 0xf6, 0xf4, 0x4b, 0x81, 0xae, 0x04, 0x3a, 0xcd, 0xe7, 0x60, 0x09, 0xcc, 0x40,
	0xe6, 0x55, 0xe2, 0x22, 0xa5, 0x15, 0x43, 0xaf, 0xb9, 0x89, 0xe0, 0x3a, 0xc6, 0xce, 0x73, 0xc5,
	0xa4, 0x9b, 0x08, 0x74, 0x30, 0xf7, 0x9f, 0x34, 0x64, 0x03, 0x36, 0xd0, 0x53, 0x90, 0x5d, 0xae,
	0x2e, 0x2f, 0x2e, 0x48, 0x67, 0x56, 0x5f, 0x5a, 0xfd, 0xd8, 0xc7, 0x57, 0xf9, 0x04, 0x2a, 0xc2,
	0x11, 0x26, 0x0a, 0x3c, 0x61, 0xf8, 0xf3, 0x37, 0xde, 0xfd, 0xd3, 0x7f, 0x0f, 0x0e, 0x0e, 0x0e,
	0x38, 0x34, 0x03, 0xe3, 0x0c, 0x11, 0x6e, 0xb0, 0xf9, 0xf3, 0xbf, 0xbb, 0xfc, 0xdb, 0x7b, 0x0c,
	0x74, 0x0a, 0x66, 0x3a, 0xa0, 0xae, 0x8d, 0x33, 0x7f, 0xe9, 0x9d, 0xbd, 0x2f, 0x26, 0xd1, 0xfb,
	0xe0, 0x58, 0x14, 0x1c, 0xed, 0x5d, 0xf9, 0xef, 0x5c, 0xbb, 0x77, 0xeb, 0x0e, 0xd3, 0x7f, 0x12,
	0x84, 0x58, 0xfd, 0xb4, 0x7d, 0xe4, 0xbf, 0xff, 0xa3, 0x5f, 0x5d, 0xbc, 0xcb, 0x80, 0xc7, 0x61,
	0xaa, 0x0b, 0x90, 0xb5, 0x7b, 0xfc, 0xcd, 0xb7, 0xfe, 0xf9, 0xfb, 0x21, 0x34, 0x03, 0x93, 0xb1,
	0x30, 0x96, 0x6e, 0xfc, 0xaf, 0x7f, 0x70, 0xfd, 0xad, 0x74, 0x4f, 0x5d, 0x6e, 0x13, 0xc5, 0x5f,
	0xbb, 0x75, 0xf3, 0x52, 0xaa, 0xab, 0x2e, 0xd6, 0xef, 0xf0, 0x3f, 0x7c, 0xf7, 0x9d, 0x5f, 0xa4,
	0x50, 0x19, 0xc4, 0x58, 0x50, 0xa0, 0x33, 0xe1, 0x2f, 0xee, 0xef, 0x7d, 0xf3, 0x7f, 0x6c, 0x23,
	0xf3, 0x50, 0x8c, 0x5d, 0xe0, 0x6b, 0x08, 0xf8, 0xaf, 0x9f, 0xbf, 0x70, 0xd9, 0x83, 0x9f, 0x80,
	0x42, 0x14, 0xee, 0xbf, 0xae, 0xf9, 0xef, 0xdd, 0xfe, 0xcb, 0xb7, 0x53, 0xe8, 0x18, 0x3c, 0x1b,
	0xc5, 0x75, 0x2e, 0x56, 0xfe, 0x2b, 0x6f, 0x5f, 0xfd, 0x77, 0x12, 0xcd, 0xc2, 0xd1, 0x28, 0x2a,
	0x74, 0x01, 0xf0, 0xe7, 0xf6, 0x7e, 0xfe, 0x1a, 0x9a, 0x8b, 0x0b, 0x7c, 0xe4, 0xb2, 0xe0, 0xaf,
	0x7c, 0xe9, 0xc6, 0x07, 0xbb, 0xfb, 0xc0, 0x5f, 0xd5, 0xf8, 0x3f, 0xff, 0xe6, 0x8f, 0x9f, 0xf3,
	0x52, 0xef, 0xbd, 0xdd, 0x68, 0xf8, 0x8a, 0x2d, 0xff, 0x85, 0x6f, 0x5d, 0xf8, 0x7c, 0x1a, 0xcd,
	0xc3, 0x89, 0xd8, 0x7d, 0x45, 0x6a, 0x15, 0xff, 0xb5, 0x83, 0xbf, 0x8f, 0xa3, 0xb9, 0x2e, 0x54,
	0x82, 0x09, 0x78, 0xee, 0xa7, 0x77, 0xfe, 0x95, 0xee, 0x89, 0xed, 0x1c, 0x86, 0x9f, 0xec, 0xdf,
	0xb9, 0x3b, 0x2c, 0x0c, 0xef, 0x9d, 0x2b, 0x24, 0x16, 0x2e, 0x66, 0x61, 0xac, 0xba, 0xb6, 0xbc,
	0xd4, 0xc1, 0xa3, 0xd7, 0x61, 0xaa, 0xf7, 0x9b, 0x72, 0x3e, 0x54, 0x1b, 0x7a, 0x9f, 0x24, 0x61,
	0xba, 0xdd, 0x7c, 0x60, 0x59, 0x36, 0x1a, 0xba, 0x23, 0x05, 0x01, 0x62, 0x02, 0xd5, 0xa1, 0xd0,
	0xe7, 0x71, 0x58, 0xea, 0x65, 0x33, 0x8a, 0x17, 0xf2, 0x01, 0xbc, 0xaf, 0x02, 0x89, 0x09, 0xb4,
	0x1a, 0xf8, 0x35, 0xd7, 0x79, 0xda, 0x1d, 0xeb, 0xb3, 0x2f, 0x8a, 0x12, 0xc6, 0xda, 0xdb, 0xa9,
	0xe8, 0xce, 0xe2, 0x82, 0x98, 0x40, 0x67, 0x60, 0xa2, 0xdb, 0x8b, 0xed, 0x64, 0x5f, 0x95, 0x0c,
	0x28, 0xbc, 0xa7, 0xad, 0x75, 0xdd, 0xb1, 0x54, 0x4a, 0xf3, 0x15, 0x78, 0x3a, 0xfe, 0x31, 0x76,
	0xbc, 0x8f, 0x52, 0x06, 0x8b, 0x53, 0x19, 0xcf, 0x94, 0xbe, 0xb2, 0xee, 0x87, 0xa9, 0x0b, 0x8c,
	0x53, 0xbb, 0x16, 0x61, 0xea, 0x3d, 0xa0, 0xfa, 0x31, 0x65, 0xb0, 0xa0, 0x4b, 0x3f, 0xf0, 0xbc,
	0x98, 0x40, 0xaf, 0xc1, 0xb3, 0x3d, 0xdf, 0x45, 0xa7, 0xfb, 0x28, 0x0e, 0xa0, 0x63, 0xf4, 0x7f,
	0x1a, 0x84, 0x1e, 0xaf, 0x97, 0xb9, 0x3e, 0xda, 0x7d, 0x58, 0x21, 0x17, 0xd3, 0x5a, 0xbb, 0x29,
	0xfd, 0x29, 0xc8, 0x77, 0x7d, 0x8e, 0xcc, 0xf6, 0xd2, 0xef, 0x47, 0x0a, 0xb1, 0xcd, 0x3e, 0xcd,
	0x8d, 0xf1, 0x2e, 0xcf, 0x8d, 0x13, 0xbd, 0x74, 0x77, 0x70, 0x42, 0xb6, 0xad, 0xf9, 0x05, 0xc3,
	0xa8, 0x53, 0xc2, 0x93, 0xbd, 0xfa, 0xfb, 0x53, 0xbd, 0xf4, 0x86, 0xc0, 0x31, 0x0e, 0x97, 0x82,
	0x45, 0x25, 0xda, 0xa3, 0xf7, 0x2c, 0x2a, 0x11, 0x78, 0x94, 0x7e, 0x4c, 0xc6, 0x04, 0x3a, 0xd0,
	0xbe, 0x19, 0xe3, 0x47, 0xc7, 0x6c, 0xe0, 0x93, 0x51, 0xf7, 0xf8, 0xfb, 0xe8, 0xbe, 0xee, 0xf1,
	0x81, 0xa3, 0xe4, 0x09, 0x14, 0xfb, 0x36, 0xae, 0xcf, 0xf5, 0x09, 0x6c, 0x64, 0x45, 0xd4, 0xcc,
	0x56, 0xc4, 0x47, 0xc1, 0x22, 0x7b, 0xfa, 0x41, 0x0a, 0xbb, 0x30, 0x1e, 0xc8, 0xcd, 0xb6, 0x5c,
	0x4c, 0x20, 0x2d, 0xd6, 0x4e, 0xa7, 0xe3, 0xbc, 0x1f, 0x3b, 0x6d, 0xb4, 0xd0, 0xfb, 0x6f, 0xa8,
	0x98, 0x78, 0xe1, 0x95, 0xdb, 0xd7, 0x0b, 0xdc, 0x95, 0xfd, 0x02, 0x77, 0x75, 0xbf, 0xc0, 0xfd,
	0x6d, 0xbf, 0xc0, 0x7d, 0xe2, 0xc3, 0x0e, 0xc1, 0x5a, 0xcd, 0xc2, 0x5a, 0x49, 0x35, 0xca, 0xad,
	0xef, 0x79, 0x9b, 0x58, 0x67, 0x89, 0x55, 0xc6, 0xa6, 0x59, 0x76, 0x3f, 0x55, 0x99, 0x94, 0x7d,
	0x9a, 0xfd, 0xdf, 0x9b, 0x69, 0xba, 0xb1, 0xc5, 0xff, 0x07, 0x00, 0x00, 0xff, 0xff, 0x85, 0xa5,
	0xf1, 0x7d, 0xc4, 0x19, 0x00, 0x00,
}

func (this *ClientSession) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 18)
	s = append(s, "&authsession.ClientSession{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Ip: "+fmt.Sprintf("%#v", this.Ip)+",\n")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	s = append(s, "ApiId: "+fmt.Sprintf("%#v", this.ApiId)+",\n")
	s = append(s, "DeviceModel: "+fmt.Sprintf("%#v", this.DeviceModel)+",\n")
	s = append(s, "SystemVersion: "+fmt.Sprintf("%#v", this.SystemVersion)+",\n")
	s = append(s, "AppVersion: "+fmt.Sprintf("%#v", this.AppVersion)+",\n")
	s = append(s, "SystemLangCode: "+fmt.Sprintf("%#v", this.SystemLangCode)+",\n")
	s = append(s, "LangPack: "+fmt.Sprintf("%#v", this.LangPack)+",\n")
	s = append(s, "LangCode: "+fmt.Sprintf("%#v", this.LangCode)+",\n")
	s = append(s, "Proxy: "+fmt.Sprintf("%#v", this.Proxy)+",\n")
	s = append(s, "Params: "+fmt.Sprintf("%#v", this.Params)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLClientSession) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsession.TLClientSession{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *AuthKeyStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 12)
	s = append(s, "&authsession.AuthKeyStateData{")
	s = append(s, "PredicateName: "+fmt.Sprintf("%#v", this.PredicateName)+",\n")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "KeyState: "+fmt.Sprintf("%#v", this.KeyState)+",\n")
	s = append(s, "Layer: "+fmt.Sprintf("%#v", this.Layer)+",\n")
	s = append(s, "ClientType: "+fmt.Sprintf("%#v", this.ClientType)+",\n")
	s = append(s, "AndroidPushSessionId: "+fmt.Sprintf("%#v", this.AndroidPushSessionId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthKeyStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsession.TLAuthKeyStateData{")
	if this.Data2 != nil {
		s = append(s, "Data2: "+fmt.Sprintf("%#v", this.Data2)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetAuthorizations) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionGetAuthorizations{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "ExcludeAuthKeyId: "+fmt.Sprintf("%#v", this.ExcludeAuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionResetAuthorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionResetAuthorization{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Hash: "+fmt.Sprintf("%#v", this.Hash)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetLayer) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetLayer{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetLangPack) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetLangPack{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetClient) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetClient{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetLangCode) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetLangCode{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetUserId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetUserId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetPushSessionId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionGetPushSessionId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "TokenType: "+fmt.Sprintf("%#v", this.TokenType)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetFutureSalts) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionGetFutureSalts{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "Num: "+fmt.Sprintf("%#v", this.Num)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionQueryAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionQueryAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionSetAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 8)
	s = append(s, "&authsession.TLAuthsessionSetAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.AuthKey != nil {
		s = append(s, "AuthKey: "+fmt.Sprintf("%#v", this.AuthKey)+",\n")
	}
	if this.FutureSalt != nil {
		s = append(s, "FutureSalt: "+fmt.Sprintf("%#v", this.FutureSalt)+",\n")
	}
	s = append(s, "ExpiresIn: "+fmt.Sprintf("%#v", this.ExpiresIn)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionBindAuthKeyUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionBindAuthKeyUser{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionUnbindAuthKeyUser) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 7)
	s = append(s, "&authsession.TLAuthsessionUnbindAuthKeyUser{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	s = append(s, "UserId: "+fmt.Sprintf("%#v", this.UserId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetPermAuthKeyId) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetPermAuthKeyId{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionBindTempAuthKey) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 9)
	s = append(s, "&authsession.TLAuthsessionBindTempAuthKey{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "PermAuthKeyId: "+fmt.Sprintf("%#v", this.PermAuthKeyId)+",\n")
	s = append(s, "Nonce: "+fmt.Sprintf("%#v", this.Nonce)+",\n")
	s = append(s, "ExpiresAt: "+fmt.Sprintf("%#v", this.ExpiresAt)+",\n")
	s = append(s, "EncryptedMessage: "+fmt.Sprintf("%#v", this.EncryptedMessage)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionSetClientSessionInfo) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionSetClientSessionInfo{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	if this.Data != nil {
		s = append(s, "Data: "+fmt.Sprintf("%#v", this.Data)+",\n")
	}
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetAuthorization) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetAuthorization{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *TLAuthsessionGetAuthStateData) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 6)
	s = append(s, "&authsession.TLAuthsessionGetAuthStateData{")
	s = append(s, "Constructor: "+fmt.Sprintf("%#v", this.Constructor)+",\n")
	s = append(s, "AuthKeyId: "+fmt.Sprintf("%#v", this.AuthKeyId)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func (this *Vector_Long) GoString() string {
	if this == nil {
		return "nil"
	}
	s := make([]string, 0, 5)
	s = append(s, "&authsession.Vector_Long{")
	s = append(s, "Datas: "+fmt.Sprintf("%#v", this.Datas)+",\n")
	if this.XXX_unrecognized != nil {
		s = append(s, "XXX_unrecognized:"+fmt.Sprintf("%#v", this.XXX_unrecognized)+",\n")
	}
	s = append(s, "}")
	return strings.Join(s, "")
}
func valueToGoStringAuthsessionTl(v interface{}, typ string) string {
	rv := reflect.ValueOf(v)
	if rv.IsNil() {
		return "nil"
	}
	pv := reflect.Indirect(rv).Interface()
	return fmt.Sprintf("func(v %v) *%v { return &v } ( %#v )", typ, typ, pv)
}

// Reference imports to suppress errors if they are not otherwise used.
var _ context.Context
var _ grpc.ClientConn

// This is a compile-time assertion to ensure that this generated file
// is compatible with the grpc package it is being compiled against.
const _ = grpc.SupportPackageIsVersion4

// RPCAuthsessionClient is the client API for RPCAuthsession service.
//
// For semantics around ctx use and closing/ending streaming RPCs, please refer to https://godoc.org/google.golang.org/grpc#ClientConn.NewStream.
type RPCAuthsessionClient interface {
	// authsession.getAuthorizations user_id:long exclude_auth_keyId:long = account.Authorizations;
	AuthsessionGetAuthorizations(ctx context.Context, in *TLAuthsessionGetAuthorizations, opts ...grpc.CallOption) (*mtproto.Account_Authorizations, error)
	// authsession.resetAuthorization user_id:long auth_key_id:long hash:long = Vector<long>;
	AuthsessionResetAuthorization(ctx context.Context, in *TLAuthsessionResetAuthorization, opts ...grpc.CallOption) (*Vector_Long, error)
	// authsession.getLayer auth_key_id:long = Int32;
	AuthsessionGetLayer(ctx context.Context, in *TLAuthsessionGetLayer, opts ...grpc.CallOption) (*mtproto.Int32, error)
	// authsession.getLangPack auth_key_id:long = String;
	AuthsessionGetLangPack(ctx context.Context, in *TLAuthsessionGetLangPack, opts ...grpc.CallOption) (*mtproto.String, error)
	// authsession.getClient auth_key_id:long = String;
	AuthsessionGetClient(ctx context.Context, in *TLAuthsessionGetClient, opts ...grpc.CallOption) (*mtproto.String, error)
	// authsession.getLangCode auth_key_id:long = String;
	AuthsessionGetLangCode(ctx context.Context, in *TLAuthsessionGetLangCode, opts ...grpc.CallOption) (*mtproto.String, error)
	// authsession.getUserId auth_key_id:long = Int64;
	AuthsessionGetUserId(ctx context.Context, in *TLAuthsessionGetUserId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// authsession.getPushSessionId user_id:long auth_key_id:long token_type:int = Int64;
	AuthsessionGetPushSessionId(ctx context.Context, in *TLAuthsessionGetPushSessionId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// authsession.getFutureSalts auth_key_id:long num:int = FutureSalts;
	AuthsessionGetFutureSalts(ctx context.Context, in *TLAuthsessionGetFutureSalts, opts ...grpc.CallOption) (*mtproto.FutureSalts, error)
	// authsession.queryAuthKey auth_key_id:long = AuthKeyInfo;
	AuthsessionQueryAuthKey(ctx context.Context, in *TLAuthsessionQueryAuthKey, opts ...grpc.CallOption) (*mtproto.AuthKeyInfo, error)
	// authsession.setAuthKey auth_key:AuthKeyInfo future_salt:FutureSalt expires_in:int = Bool;
	AuthsessionSetAuthKey(ctx context.Context, in *TLAuthsessionSetAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// authsession.bindAuthKeyUser auth_key_id:long user_id:long = Int64;
	AuthsessionBindAuthKeyUser(ctx context.Context, in *TLAuthsessionBindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// authsession.unbindAuthKeyUser auth_key_id:long user_id:long = Bool;
	AuthsessionUnbindAuthKeyUser(ctx context.Context, in *TLAuthsessionUnbindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// authsession.getPermAuthKeyId auth_key_id:long= Int64;
	AuthsessionGetPermAuthKeyId(ctx context.Context, in *TLAuthsessionGetPermAuthKeyId, opts ...grpc.CallOption) (*mtproto.Int64, error)
	// authsession.bindTempAuthKey perm_auth_key_id:long nonce:long expires_at:int encrypted_message:bytes = Bool;
	AuthsessionBindTempAuthKey(ctx context.Context, in *TLAuthsessionBindTempAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// authsession.setClientSessionInfo data:ClientSession = Bool;
	AuthsessionSetClientSessionInfo(ctx context.Context, in *TLAuthsessionSetClientSessionInfo, opts ...grpc.CallOption) (*mtproto.Bool, error)
	// authsession.getAuthorization auth_key_id:long = Authorization;
	AuthsessionGetAuthorization(ctx context.Context, in *TLAuthsessionGetAuthorization, opts ...grpc.CallOption) (*mtproto.Authorization, error)
	// authsession.getAuthStateData auth_key_id:long = AuthKeyStateData;
	AuthsessionGetAuthStateData(ctx context.Context, in *TLAuthsessionGetAuthStateData, opts ...grpc.CallOption) (*AuthKeyStateData, error)
}

type rPCAuthsessionClient struct {
	cc *grpc.ClientConn
}

func NewRPCAuthsessionClient(cc *grpc.ClientConn) RPCAuthsessionClient {
	return &rPCAuthsessionClient{cc}
}

func (c *rPCAuthsessionClient) AuthsessionGetAuthorizations(ctx context.Context, in *TLAuthsessionGetAuthorizations, opts ...grpc.CallOption) (*mtproto.Account_Authorizations, error) {
	out := new(mtproto.Account_Authorizations)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getAuthorizations", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionResetAuthorization(ctx context.Context, in *TLAuthsessionResetAuthorization, opts ...grpc.CallOption) (*Vector_Long, error) {
	out := new(Vector_Long)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_resetAuthorization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetLayer(ctx context.Context, in *TLAuthsessionGetLayer, opts ...grpc.CallOption) (*mtproto.Int32, error) {
	out := new(mtproto.Int32)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getLayer", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetLangPack(ctx context.Context, in *TLAuthsessionGetLangPack, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getLangPack", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetClient(ctx context.Context, in *TLAuthsessionGetClient, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getClient", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetLangCode(ctx context.Context, in *TLAuthsessionGetLangCode, opts ...grpc.CallOption) (*mtproto.String, error) {
	out := new(mtproto.String)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getLangCode", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetUserId(ctx context.Context, in *TLAuthsessionGetUserId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getUserId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetPushSessionId(ctx context.Context, in *TLAuthsessionGetPushSessionId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getPushSessionId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetFutureSalts(ctx context.Context, in *TLAuthsessionGetFutureSalts, opts ...grpc.CallOption) (*mtproto.FutureSalts, error) {
	out := new(mtproto.FutureSalts)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getFutureSalts", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionQueryAuthKey(ctx context.Context, in *TLAuthsessionQueryAuthKey, opts ...grpc.CallOption) (*mtproto.AuthKeyInfo, error) {
	out := new(mtproto.AuthKeyInfo)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_queryAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionSetAuthKey(ctx context.Context, in *TLAuthsessionSetAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_setAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionBindAuthKeyUser(ctx context.Context, in *TLAuthsessionBindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_bindAuthKeyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionUnbindAuthKeyUser(ctx context.Context, in *TLAuthsessionUnbindAuthKeyUser, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_unbindAuthKeyUser", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetPermAuthKeyId(ctx context.Context, in *TLAuthsessionGetPermAuthKeyId, opts ...grpc.CallOption) (*mtproto.Int64, error) {
	out := new(mtproto.Int64)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getPermAuthKeyId", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionBindTempAuthKey(ctx context.Context, in *TLAuthsessionBindTempAuthKey, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_bindTempAuthKey", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionSetClientSessionInfo(ctx context.Context, in *TLAuthsessionSetClientSessionInfo, opts ...grpc.CallOption) (*mtproto.Bool, error) {
	out := new(mtproto.Bool)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_setClientSessionInfo", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetAuthorization(ctx context.Context, in *TLAuthsessionGetAuthorization, opts ...grpc.CallOption) (*mtproto.Authorization, error) {
	out := new(mtproto.Authorization)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getAuthorization", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

func (c *rPCAuthsessionClient) AuthsessionGetAuthStateData(ctx context.Context, in *TLAuthsessionGetAuthStateData, opts ...grpc.CallOption) (*AuthKeyStateData, error) {
	out := new(AuthKeyStateData)
	err := c.cc.Invoke(ctx, "/authsession.RPCAuthsession/authsession_getAuthStateData", in, out, opts...)
	if err != nil {
		return nil, err
	}
	return out, nil
}

// RPCAuthsessionServer is the server API for RPCAuthsession service.
type RPCAuthsessionServer interface {
	// authsession.getAuthorizations user_id:long exclude_auth_keyId:long = account.Authorizations;
	AuthsessionGetAuthorizations(context.Context, *TLAuthsessionGetAuthorizations) (*mtproto.Account_Authorizations, error)
	// authsession.resetAuthorization user_id:long auth_key_id:long hash:long = Vector<long>;
	AuthsessionResetAuthorization(context.Context, *TLAuthsessionResetAuthorization) (*Vector_Long, error)
	// authsession.getLayer auth_key_id:long = Int32;
	AuthsessionGetLayer(context.Context, *TLAuthsessionGetLayer) (*mtproto.Int32, error)
	// authsession.getLangPack auth_key_id:long = String;
	AuthsessionGetLangPack(context.Context, *TLAuthsessionGetLangPack) (*mtproto.String, error)
	// authsession.getClient auth_key_id:long = String;
	AuthsessionGetClient(context.Context, *TLAuthsessionGetClient) (*mtproto.String, error)
	// authsession.getLangCode auth_key_id:long = String;
	AuthsessionGetLangCode(context.Context, *TLAuthsessionGetLangCode) (*mtproto.String, error)
	// authsession.getUserId auth_key_id:long = Int64;
	AuthsessionGetUserId(context.Context, *TLAuthsessionGetUserId) (*mtproto.Int64, error)
	// authsession.getPushSessionId user_id:long auth_key_id:long token_type:int = Int64;
	AuthsessionGetPushSessionId(context.Context, *TLAuthsessionGetPushSessionId) (*mtproto.Int64, error)
	// authsession.getFutureSalts auth_key_id:long num:int = FutureSalts;
	AuthsessionGetFutureSalts(context.Context, *TLAuthsessionGetFutureSalts) (*mtproto.FutureSalts, error)
	// authsession.queryAuthKey auth_key_id:long = AuthKeyInfo;
	AuthsessionQueryAuthKey(context.Context, *TLAuthsessionQueryAuthKey) (*mtproto.AuthKeyInfo, error)
	// authsession.setAuthKey auth_key:AuthKeyInfo future_salt:FutureSalt expires_in:int = Bool;
	AuthsessionSetAuthKey(context.Context, *TLAuthsessionSetAuthKey) (*mtproto.Bool, error)
	// authsession.bindAuthKeyUser auth_key_id:long user_id:long = Int64;
	AuthsessionBindAuthKeyUser(context.Context, *TLAuthsessionBindAuthKeyUser) (*mtproto.Int64, error)
	// authsession.unbindAuthKeyUser auth_key_id:long user_id:long = Bool;
	AuthsessionUnbindAuthKeyUser(context.Context, *TLAuthsessionUnbindAuthKeyUser) (*mtproto.Bool, error)
	// authsession.getPermAuthKeyId auth_key_id:long= Int64;
	AuthsessionGetPermAuthKeyId(context.Context, *TLAuthsessionGetPermAuthKeyId) (*mtproto.Int64, error)
	// authsession.bindTempAuthKey perm_auth_key_id:long nonce:long expires_at:int encrypted_message:bytes = Bool;
	AuthsessionBindTempAuthKey(context.Context, *TLAuthsessionBindTempAuthKey) (*mtproto.Bool, error)
	// authsession.setClientSessionInfo data:ClientSession = Bool;
	AuthsessionSetClientSessionInfo(context.Context, *TLAuthsessionSetClientSessionInfo) (*mtproto.Bool, error)
	// authsession.getAuthorization auth_key_id:long = Authorization;
	AuthsessionGetAuthorization(context.Context, *TLAuthsessionGetAuthorization) (*mtproto.Authorization, error)
	// authsession.getAuthStateData auth_key_id:long = AuthKeyStateData;
	AuthsessionGetAuthStateData(context.Context, *TLAuthsessionGetAuthStateData) (*AuthKeyStateData, error)
}

// UnimplementedRPCAuthsessionServer can be embedded to have forward compatible implementations.
type UnimplementedRPCAuthsessionServer struct {
}

func (*UnimplementedRPCAuthsessionServer) AuthsessionGetAuthorizations(ctx context.Context, req *TLAuthsessionGetAuthorizations) (*mtproto.Account_Authorizations, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetAuthorizations not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionResetAuthorization(ctx context.Context, req *TLAuthsessionResetAuthorization) (*Vector_Long, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionResetAuthorization not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetLayer(ctx context.Context, req *TLAuthsessionGetLayer) (*mtproto.Int32, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetLayer not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetLangPack(ctx context.Context, req *TLAuthsessionGetLangPack) (*mtproto.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetLangPack not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetClient(ctx context.Context, req *TLAuthsessionGetClient) (*mtproto.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetClient not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetLangCode(ctx context.Context, req *TLAuthsessionGetLangCode) (*mtproto.String, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetLangCode not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetUserId(ctx context.Context, req *TLAuthsessionGetUserId) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetUserId not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetPushSessionId(ctx context.Context, req *TLAuthsessionGetPushSessionId) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetPushSessionId not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetFutureSalts(ctx context.Context, req *TLAuthsessionGetFutureSalts) (*mtproto.FutureSalts, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetFutureSalts not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionQueryAuthKey(ctx context.Context, req *TLAuthsessionQueryAuthKey) (*mtproto.AuthKeyInfo, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionQueryAuthKey not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionSetAuthKey(ctx context.Context, req *TLAuthsessionSetAuthKey) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionSetAuthKey not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionBindAuthKeyUser(ctx context.Context, req *TLAuthsessionBindAuthKeyUser) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionBindAuthKeyUser not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionUnbindAuthKeyUser(ctx context.Context, req *TLAuthsessionUnbindAuthKeyUser) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionUnbindAuthKeyUser not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetPermAuthKeyId(ctx context.Context, req *TLAuthsessionGetPermAuthKeyId) (*mtproto.Int64, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetPermAuthKeyId not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionBindTempAuthKey(ctx context.Context, req *TLAuthsessionBindTempAuthKey) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionBindTempAuthKey not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionSetClientSessionInfo(ctx context.Context, req *TLAuthsessionSetClientSessionInfo) (*mtproto.Bool, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionSetClientSessionInfo not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetAuthorization(ctx context.Context, req *TLAuthsessionGetAuthorization) (*mtproto.Authorization, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetAuthorization not implemented")
}
func (*UnimplementedRPCAuthsessionServer) AuthsessionGetAuthStateData(ctx context.Context, req *TLAuthsessionGetAuthStateData) (*AuthKeyStateData, error) {
	return nil, status.Errorf(codes.Unimplemented, "method AuthsessionGetAuthStateData not implemented")
}

func RegisterRPCAuthsessionServer(s *grpc.Server, srv RPCAuthsessionServer) {
	s.RegisterService(&_RPCAuthsession_serviceDesc, srv)
}

func _RPCAuthsession_AuthsessionGetAuthorizations_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetAuthorizations)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorizations(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetAuthorizations",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorizations(ctx, req.(*TLAuthsessionGetAuthorizations))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionResetAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionResetAuthorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionResetAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionResetAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionResetAuthorization(ctx, req.(*TLAuthsessionResetAuthorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetLayer_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetLayer)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetLayer(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetLayer",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetLayer(ctx, req.(*TLAuthsessionGetLayer))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetLangPack_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetLangPack)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangPack(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetLangPack",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangPack(ctx, req.(*TLAuthsessionGetLangPack))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetClient_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetClient)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetClient(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetClient",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetClient(ctx, req.(*TLAuthsessionGetClient))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetLangCode_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetLangCode)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangCode(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetLangCode",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetLangCode(ctx, req.(*TLAuthsessionGetLangCode))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetUserId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetUserId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetUserId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetUserId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetUserId(ctx, req.(*TLAuthsessionGetUserId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetPushSessionId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetPushSessionId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetPushSessionId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetPushSessionId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetPushSessionId(ctx, req.(*TLAuthsessionGetPushSessionId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetFutureSalts_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetFutureSalts)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetFutureSalts(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetFutureSalts",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetFutureSalts(ctx, req.(*TLAuthsessionGetFutureSalts))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionQueryAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionQueryAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionQueryAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionQueryAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionQueryAuthKey(ctx, req.(*TLAuthsessionQueryAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionSetAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionSetAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionSetAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionSetAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionSetAuthKey(ctx, req.(*TLAuthsessionSetAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionBindAuthKeyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionBindAuthKeyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionBindAuthKeyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionBindAuthKeyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionBindAuthKeyUser(ctx, req.(*TLAuthsessionBindAuthKeyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionUnbindAuthKeyUser_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionUnbindAuthKeyUser)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionUnbindAuthKeyUser(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionUnbindAuthKeyUser",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionUnbindAuthKeyUser(ctx, req.(*TLAuthsessionUnbindAuthKeyUser))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetPermAuthKeyId_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetPermAuthKeyId)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetPermAuthKeyId(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetPermAuthKeyId",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetPermAuthKeyId(ctx, req.(*TLAuthsessionGetPermAuthKeyId))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionBindTempAuthKey_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionBindTempAuthKey)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionBindTempAuthKey(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionBindTempAuthKey",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionBindTempAuthKey(ctx, req.(*TLAuthsessionBindTempAuthKey))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionSetClientSessionInfo_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionSetClientSessionInfo)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionSetClientSessionInfo(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionSetClientSessionInfo",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionSetClientSessionInfo(ctx, req.(*TLAuthsessionSetClientSessionInfo))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetAuthorization_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetAuthorization)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorization(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetAuthorization",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthorization(ctx, req.(*TLAuthsessionGetAuthorization))
	}
	return interceptor(ctx, in, info, handler)
}

func _RPCAuthsession_AuthsessionGetAuthStateData_Handler(srv interface{}, ctx context.Context, dec func(interface{}) error, interceptor grpc.UnaryServerInterceptor) (interface{}, error) {
	in := new(TLAuthsessionGetAuthStateData)
	if err := dec(in); err != nil {
		return nil, err
	}
	if interceptor == nil {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthStateData(ctx, in)
	}
	info := &grpc.UnaryServerInfo{
		Server:     srv,
		FullMethod: "/authsession.RPCAuthsession/AuthsessionGetAuthStateData",
	}
	handler := func(ctx context.Context, req interface{}) (interface{}, error) {
		return srv.(RPCAuthsessionServer).AuthsessionGetAuthStateData(ctx, req.(*TLAuthsessionGetAuthStateData))
	}
	return interceptor(ctx, in, info, handler)
}

var _RPCAuthsession_serviceDesc = grpc.ServiceDesc{
	ServiceName: "authsession.RPCAuthsession",
	HandlerType: (*RPCAuthsessionServer)(nil),
	Methods: []grpc.MethodDesc{
		{
			MethodName: "authsession_getAuthorizations",
			Handler:    _RPCAuthsession_AuthsessionGetAuthorizations_Handler,
		},
		{
			MethodName: "authsession_resetAuthorization",
			Handler:    _RPCAuthsession_AuthsessionResetAuthorization_Handler,
		},
		{
			MethodName: "authsession_getLayer",
			Handler:    _RPCAuthsession_AuthsessionGetLayer_Handler,
		},
		{
			MethodName: "authsession_getLangPack",
			Handler:    _RPCAuthsession_AuthsessionGetLangPack_Handler,
		},
		{
			MethodName: "authsession_getClient",
			Handler:    _RPCAuthsession_AuthsessionGetClient_Handler,
		},
		{
			MethodName: "authsession_getLangCode",
			Handler:    _RPCAuthsession_AuthsessionGetLangCode_Handler,
		},
		{
			MethodName: "authsession_getUserId",
			Handler:    _RPCAuthsession_AuthsessionGetUserId_Handler,
		},
		{
			MethodName: "authsession_getPushSessionId",
			Handler:    _RPCAuthsession_AuthsessionGetPushSessionId_Handler,
		},
		{
			MethodName: "authsession_getFutureSalts",
			Handler:    _RPCAuthsession_AuthsessionGetFutureSalts_Handler,
		},
		{
			MethodName: "authsession_queryAuthKey",
			Handler:    _RPCAuthsession_AuthsessionQueryAuthKey_Handler,
		},
		{
			MethodName: "authsession_setAuthKey",
			Handler:    _RPCAuthsession_AuthsessionSetAuthKey_Handler,
		},
		{
			MethodName: "authsession_bindAuthKeyUser",
			Handler:    _RPCAuthsession_AuthsessionBindAuthKeyUser_Handler,
		},
		{
			MethodName: "authsession_unbindAuthKeyUser",
			Handler:    _RPCAuthsession_AuthsessionUnbindAuthKeyUser_Handler,
		},
		{
			MethodName: "authsession_getPermAuthKeyId",
			Handler:    _RPCAuthsession_AuthsessionGetPermAuthKeyId_Handler,
		},
		{
			MethodName: "authsession_bindTempAuthKey",
			Handler:    _RPCAuthsession_AuthsessionBindTempAuthKey_Handler,
		},
		{
			MethodName: "authsession_setClientSessionInfo",
			Handler:    _RPCAuthsession_AuthsessionSetClientSessionInfo_Handler,
		},
		{
			MethodName: "authsession_getAuthorization",
			Handler:    _RPCAuthsession_AuthsessionGetAuthorization_Handler,
		},
		{
			MethodName: "authsession_getAuthStateData",
			Handler:    _RPCAuthsession_AuthsessionGetAuthStateData_Handler,
		},
	},
	Streams:  []grpc.StreamDesc{},
	Metadata: "authsession.tl.proto",
}

func (m *ClientSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *ClientSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *ClientSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Params) > 0 {
		i -= len(m.Params)
		copy(dAtA[i:], m.Params)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Params)))
		i--
		dAtA[i] = 0x72
	}
	if len(m.Proxy) > 0 {
		i -= len(m.Proxy)
		copy(dAtA[i:], m.Proxy)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Proxy)))
		i--
		dAtA[i] = 0x6a
	}
	if len(m.LangCode) > 0 {
		i -= len(m.LangCode)
		copy(dAtA[i:], m.LangCode)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.LangCode)))
		i--
		dAtA[i] = 0x62
	}
	if len(m.LangPack) > 0 {
		i -= len(m.LangPack)
		copy(dAtA[i:], m.LangPack)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.LangPack)))
		i--
		dAtA[i] = 0x5a
	}
	if len(m.SystemLangCode) > 0 {
		i -= len(m.SystemLangCode)
		copy(dAtA[i:], m.SystemLangCode)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.SystemLangCode)))
		i--
		dAtA[i] = 0x52
	}
	if len(m.AppVersion) > 0 {
		i -= len(m.AppVersion)
		copy(dAtA[i:], m.AppVersion)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.AppVersion)))
		i--
		dAtA[i] = 0x4a
	}
	if len(m.SystemVersion) > 0 {
		i -= len(m.SystemVersion)
		copy(dAtA[i:], m.SystemVersion)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.SystemVersion)))
		i--
		dAtA[i] = 0x42
	}
	if len(m.DeviceModel) > 0 {
		i -= len(m.DeviceModel)
		copy(dAtA[i:], m.DeviceModel)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.DeviceModel)))
		i--
		dAtA[i] = 0x3a
	}
	if m.ApiId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ApiId))
		i--
		dAtA[i] = 0x30
	}
	if m.Layer != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x28
	}
	if len(m.Ip) > 0 {
		i -= len(m.Ip)
		copy(dAtA[i:], m.Ip)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.Ip)))
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLClientSession) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLClientSession) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLClientSession) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *AuthKeyStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *AuthKeyStateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *AuthKeyStateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AndroidPushSessionId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AndroidPushSessionId))
		i--
		dAtA[i] = 0x40
	}
	if m.ClientType != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ClientType))
		i--
		dAtA[i] = 0x38
	}
	if m.Layer != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Layer))
		i--
		dAtA[i] = 0x30
	}
	if m.KeyState != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.KeyState))
		i--
		dAtA[i] = 0x28
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x10
	}
	if len(m.PredicateName) > 0 {
		i -= len(m.PredicateName)
		copy(dAtA[i:], m.PredicateName)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.PredicateName)))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthKeyStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthKeyStateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthKeyStateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data2 != nil {
		{
			size, err := m.Data2.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetAuthorizations) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetAuthorizations) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetAuthorizations) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExcludeAuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ExcludeAuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionResetAuthorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionResetAuthorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionResetAuthorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Hash != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Hash))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetLayer) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetLayer) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetLayer) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetLangPack) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetLangPack) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetLangPack) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetClient) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetClient) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetClient) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetLangCode) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetLangCode) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetLangCode) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetUserId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetUserId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetUserId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetPushSessionId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetPushSessionId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetPushSessionId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.TokenType != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.TokenType))
		i--
		dAtA[i] = 0x28
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x20
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetFutureSalts) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetFutureSalts) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetFutureSalts) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Num != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Num))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionQueryAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionQueryAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionQueryAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionSetAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionSetAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionSetAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.ExpiresIn != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ExpiresIn))
		i--
		dAtA[i] = 0x28
	}
	if m.FutureSalt != nil {
		{
			size, err := m.FutureSalt.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x22
	}
	if m.AuthKey != nil {
		{
			size, err := m.AuthKey.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionBindAuthKeyUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionBindAuthKeyUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionBindAuthKeyUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionUnbindAuthKeyUser) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionUnbindAuthKeyUser) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionUnbindAuthKeyUser) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.UserId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.UserId))
		i--
		dAtA[i] = 0x20
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetPermAuthKeyId) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetPermAuthKeyId) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetPermAuthKeyId) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionBindTempAuthKey) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionBindTempAuthKey) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionBindTempAuthKey) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.EncryptedMessage) > 0 {
		i -= len(m.EncryptedMessage)
		copy(dAtA[i:], m.EncryptedMessage)
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(len(m.EncryptedMessage)))
		i--
		dAtA[i] = 0x32
	}
	if m.ExpiresAt != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.ExpiresAt))
		i--
		dAtA[i] = 0x28
	}
	if m.Nonce != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Nonce))
		i--
		dAtA[i] = 0x20
	}
	if m.PermAuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.PermAuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionSetClientSessionInfo) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionSetClientSessionInfo) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionSetClientSessionInfo) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.Data != nil {
		{
			size, err := m.Data.MarshalToSizedBuffer(dAtA[:i])
			if err != nil {
				return 0, err
			}
			i -= size
			i = encodeVarintAuthsessionTl(dAtA, i, uint64(size))
		}
		i--
		dAtA[i] = 0x1a
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetAuthorization) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetAuthorization) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetAuthorization) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *TLAuthsessionGetAuthStateData) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *TLAuthsessionGetAuthStateData) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *TLAuthsessionGetAuthStateData) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if m.AuthKeyId != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.AuthKeyId))
		i--
		dAtA[i] = 0x18
	}
	if m.Constructor != 0 {
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(m.Constructor))
		i--
		dAtA[i] = 0x8
	}
	return len(dAtA) - i, nil
}

func (m *Vector_Long) Marshal() (dAtA []byte, err error) {
	size := m.Size()
	dAtA = make([]byte, size)
	n, err := m.MarshalToSizedBuffer(dAtA[:size])
	if err != nil {
		return nil, err
	}
	return dAtA[:n], nil
}

func (m *Vector_Long) MarshalTo(dAtA []byte) (int, error) {
	size := m.Size()
	return m.MarshalToSizedBuffer(dAtA[:size])
}

func (m *Vector_Long) MarshalToSizedBuffer(dAtA []byte) (int, error) {
	i := len(dAtA)
	_ = i
	var l int
	_ = l
	if m.XXX_unrecognized != nil {
		i -= len(m.XXX_unrecognized)
		copy(dAtA[i:], m.XXX_unrecognized)
	}
	if len(m.Datas) > 0 {
		dAtA7 := make([]byte, len(m.Datas)*10)
		var j6 int
		for _, num1 := range m.Datas {
			num := uint64(num1)
			for num >= 1<<7 {
				dAtA7[j6] = uint8(uint64(num)&0x7f | 0x80)
				num >>= 7
				j6++
			}
			dAtA7[j6] = uint8(num)
			j6++
		}
		i -= j6
		copy(dAtA[i:], dAtA7[:j6])
		i = encodeVarintAuthsessionTl(dAtA, i, uint64(j6))
		i--
		dAtA[i] = 0xa
	}
	return len(dAtA) - i, nil
}

func encodeVarintAuthsessionTl(dAtA []byte, offset int, v uint64) int {
	offset -= sovAuthsessionTl(v)
	base := offset
	for v >= 1<<7 {
		dAtA[offset] = uint8(v&0x7f | 0x80)
		v >>= 7
		offset++
	}
	dAtA[offset] = uint8(v)
	return base
}
func (m *ClientSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	l = len(m.Ip)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Layer))
	}
	if m.ApiId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ApiId))
	}
	l = len(m.DeviceModel)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.SystemVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.AppVersion)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.SystemLangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.LangPack)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.LangCode)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.Proxy)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	l = len(m.Params)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLClientSession) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *AuthKeyStateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	l = len(m.PredicateName)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.KeyState != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.KeyState))
	}
	if m.Layer != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Layer))
	}
	if m.ClientType != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ClientType))
	}
	if m.AndroidPushSessionId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AndroidPushSessionId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthKeyStateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Data2 != nil {
		l = m.Data2.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetAuthorizations) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.ExcludeAuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ExcludeAuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionResetAuthorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.Hash != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Hash))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetLayer) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetLangPack) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetClient) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetLangCode) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetUserId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetPushSessionId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.TokenType != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.TokenType))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetFutureSalts) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.Num != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Num))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionQueryAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionSetAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKey != nil {
		l = m.AuthKey.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.FutureSalt != nil {
		l = m.FutureSalt.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.ExpiresIn != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ExpiresIn))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionBindAuthKeyUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionUnbindAuthKeyUser) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.UserId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.UserId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetPermAuthKeyId) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionBindTempAuthKey) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.PermAuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.PermAuthKeyId))
	}
	if m.Nonce != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Nonce))
	}
	if m.ExpiresAt != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.ExpiresAt))
	}
	l = len(m.EncryptedMessage)
	if l > 0 {
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionSetClientSessionInfo) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.Data != nil {
		l = m.Data.Size()
		n += 1 + l + sovAuthsessionTl(uint64(l))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetAuthorization) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *TLAuthsessionGetAuthStateData) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if m.Constructor != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.Constructor))
	}
	if m.AuthKeyId != 0 {
		n += 1 + sovAuthsessionTl(uint64(m.AuthKeyId))
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func (m *Vector_Long) Size() (n int) {
	if m == nil {
		return 0
	}
	var l int
	_ = l
	if len(m.Datas) > 0 {
		l = 0
		for _, e := range m.Datas {
			l += sovAuthsessionTl(uint64(e))
		}
		n += 1 + sovAuthsessionTl(uint64(l)) + l
	}
	if m.XXX_unrecognized != nil {
		n += len(m.XXX_unrecognized)
	}
	return n
}

func sovAuthsessionTl(x uint64) (n int) {
	return (math_bits.Len64(x|1) + 6) / 7
}
func sozAuthsessionTl(x uint64) (n int) {
	return sovAuthsessionTl(uint64((x << 1) ^ uint64((int64(x) >> 63))))
}
func (m *ClientSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: ClientSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: ClientSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Ip", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Ip = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ApiId", wireType)
			}
			m.ApiId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ApiId |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field DeviceModel", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.DeviceModel = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 8:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 9:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AppVersion", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.AppVersion = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 10:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field SystemLangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.SystemLangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 11:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangPack", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangPack = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 12:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field LangCode", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.LangCode = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 13:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Proxy", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Proxy = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 14:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Params", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.Params = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLClientSession) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_clientSession: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_clientSession: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &ClientSession{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *AuthKeyStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: AuthKeyStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: AuthKeyStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field PredicateName", wireType)
			}
			var stringLen uint64
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				stringLen |= uint64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			intStringLen := int(stringLen)
			if intStringLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + intStringLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.PredicateName = string(dAtA[iNdEx:postIndex])
			iNdEx = postIndex
		case 2:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field KeyState", wireType)
			}
			m.KeyState = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.KeyState |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Layer", wireType)
			}
			m.Layer = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Layer |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 7:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ClientType", wireType)
			}
			m.ClientType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ClientType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 8:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AndroidPushSessionId", wireType)
			}
			m.AndroidPushSessionId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AndroidPushSessionId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthKeyStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authKeyStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authKeyStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data2", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data2 == nil {
				m.Data2 = &AuthKeyStateData{}
			}
			if err := m.Data2.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetAuthorizations) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getAuthorizations: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getAuthorizations: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExcludeAuthKeyId", wireType)
			}
			m.ExcludeAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExcludeAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionResetAuthorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_resetAuthorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_resetAuthorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Hash", wireType)
			}
			m.Hash = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Hash |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetLayer) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getLayer: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getLayer: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetLangPack) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getLangPack: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getLangPack: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetClient) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getClient: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getClient: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetLangCode) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getLangCode: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getLangCode: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetUserId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getUserId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getUserId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetPushSessionId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getPushSessionId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getPushSessionId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field TokenType", wireType)
			}
			m.TokenType = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.TokenType |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetFutureSalts) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getFutureSalts: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getFutureSalts: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Num", wireType)
			}
			m.Num = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Num |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionQueryAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_queryAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_queryAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionSetAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_setAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_setAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKey", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.AuthKey == nil {
				m.AuthKey = &mtproto.AuthKeyInfo{}
			}
			if err := m.AuthKey.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 4:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field FutureSalt", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.FutureSalt == nil {
				m.FutureSalt = &mtproto.FutureSalt{}
			}
			if err := m.FutureSalt.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresIn", wireType)
			}
			m.ExpiresIn = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresIn |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionBindAuthKeyUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_bindAuthKeyUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_bindAuthKeyUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionUnbindAuthKeyUser) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_unbindAuthKeyUser: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_unbindAuthKeyUser: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field UserId", wireType)
			}
			m.UserId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.UserId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetPermAuthKeyId) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getPermAuthKeyId: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getPermAuthKeyId: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionBindTempAuthKey) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_bindTempAuthKey: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_bindTempAuthKey: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field PermAuthKeyId", wireType)
			}
			m.PermAuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.PermAuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 4:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Nonce", wireType)
			}
			m.Nonce = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Nonce |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 5:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field ExpiresAt", wireType)
			}
			m.ExpiresAt = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.ExpiresAt |= int32(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 6:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field EncryptedMessage", wireType)
			}
			var byteLen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				byteLen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if byteLen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + byteLen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			m.EncryptedMessage = append(m.EncryptedMessage[:0], dAtA[iNdEx:postIndex]...)
			if m.EncryptedMessage == nil {
				m.EncryptedMessage = []byte{}
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionSetClientSessionInfo) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_setClientSessionInfo: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_setClientSessionInfo: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 2 {
				return fmt.Errorf("proto: wrong wireType = %d for field Data", wireType)
			}
			var msglen int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				msglen |= int(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if msglen < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			postIndex := iNdEx + msglen
			if postIndex < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if postIndex > l {
				return io.ErrUnexpectedEOF
			}
			if m.Data == nil {
				m.Data = &ClientSession{}
			}
			if err := m.Data.Unmarshal(dAtA[iNdEx:postIndex]); err != nil {
				return err
			}
			iNdEx = postIndex
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetAuthorization) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getAuthorization: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getAuthorization: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *TLAuthsessionGetAuthStateData) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: TL_authsession_getAuthStateData: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: TL_authsession_getAuthStateData: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field Constructor", wireType)
			}
			m.Constructor = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.Constructor |= TLConstructor(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		case 3:
			if wireType != 0 {
				return fmt.Errorf("proto: wrong wireType = %d for field AuthKeyId", wireType)
			}
			m.AuthKeyId = 0
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				m.AuthKeyId |= int64(b&0x7F) << shift
				if b < 0x80 {
					break
				}
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func (m *Vector_Long) Unmarshal(dAtA []byte) error {
	l := len(dAtA)
	iNdEx := 0
	for iNdEx < l {
		preIndex := iNdEx
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= uint64(b&0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		fieldNum := int32(wire >> 3)
		wireType := int(wire & 0x7)
		if wireType == 4 {
			return fmt.Errorf("proto: Vector_Long: wiretype end group for non-group")
		}
		if fieldNum <= 0 {
			return fmt.Errorf("proto: Vector_Long: illegal tag %d (wire type %d)", fieldNum, wire)
		}
		switch fieldNum {
		case 1:
			if wireType == 0 {
				var v int64
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthsessionTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					v |= int64(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				m.Datas = append(m.Datas, v)
			} else if wireType == 2 {
				var packedLen int
				for shift := uint(0); ; shift += 7 {
					if shift >= 64 {
						return ErrIntOverflowAuthsessionTl
					}
					if iNdEx >= l {
						return io.ErrUnexpectedEOF
					}
					b := dAtA[iNdEx]
					iNdEx++
					packedLen |= int(b&0x7F) << shift
					if b < 0x80 {
						break
					}
				}
				if packedLen < 0 {
					return ErrInvalidLengthAuthsessionTl
				}
				postIndex := iNdEx + packedLen
				if postIndex < 0 {
					return ErrInvalidLengthAuthsessionTl
				}
				if postIndex > l {
					return io.ErrUnexpectedEOF
				}
				var elementCount int
				var count int
				for _, integer := range dAtA[iNdEx:postIndex] {
					if integer < 128 {
						count++
					}
				}
				elementCount = count
				if elementCount != 0 && len(m.Datas) == 0 {
					m.Datas = make([]int64, 0, elementCount)
				}
				for iNdEx < postIndex {
					var v int64
					for shift := uint(0); ; shift += 7 {
						if shift >= 64 {
							return ErrIntOverflowAuthsessionTl
						}
						if iNdEx >= l {
							return io.ErrUnexpectedEOF
						}
						b := dAtA[iNdEx]
						iNdEx++
						v |= int64(b&0x7F) << shift
						if b < 0x80 {
							break
						}
					}
					m.Datas = append(m.Datas, v)
				}
			} else {
				return fmt.Errorf("proto: wrong wireType = %d for field Datas", wireType)
			}
		default:
			iNdEx = preIndex
			skippy, err := skipAuthsessionTl(dAtA[iNdEx:])
			if err != nil {
				return err
			}
			if (skippy < 0) || (iNdEx+skippy) < 0 {
				return ErrInvalidLengthAuthsessionTl
			}
			if (iNdEx + skippy) > l {
				return io.ErrUnexpectedEOF
			}
			m.XXX_unrecognized = append(m.XXX_unrecognized, dAtA[iNdEx:iNdEx+skippy]...)
			iNdEx += skippy
		}
	}

	if iNdEx > l {
		return io.ErrUnexpectedEOF
	}
	return nil
}
func skipAuthsessionTl(dAtA []byte) (n int, err error) {
	l := len(dAtA)
	iNdEx := 0
	depth := 0
	for iNdEx < l {
		var wire uint64
		for shift := uint(0); ; shift += 7 {
			if shift >= 64 {
				return 0, ErrIntOverflowAuthsessionTl
			}
			if iNdEx >= l {
				return 0, io.ErrUnexpectedEOF
			}
			b := dAtA[iNdEx]
			iNdEx++
			wire |= (uint64(b) & 0x7F) << shift
			if b < 0x80 {
				break
			}
		}
		wireType := int(wire & 0x7)
		switch wireType {
		case 0:
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				iNdEx++
				if dAtA[iNdEx-1] < 0x80 {
					break
				}
			}
		case 1:
			iNdEx += 8
		case 2:
			var length int
			for shift := uint(0); ; shift += 7 {
				if shift >= 64 {
					return 0, ErrIntOverflowAuthsessionTl
				}
				if iNdEx >= l {
					return 0, io.ErrUnexpectedEOF
				}
				b := dAtA[iNdEx]
				iNdEx++
				length |= (int(b) & 0x7F) << shift
				if b < 0x80 {
					break
				}
			}
			if length < 0 {
				return 0, ErrInvalidLengthAuthsessionTl
			}
			iNdEx += length
		case 3:
			depth++
		case 4:
			if depth == 0 {
				return 0, ErrUnexpectedEndOfGroupAuthsessionTl
			}
			depth--
		case 5:
			iNdEx += 4
		default:
			return 0, fmt.Errorf("proto: illegal wireType %d", wireType)
		}
		if iNdEx < 0 {
			return 0, ErrInvalidLengthAuthsessionTl
		}
		if depth == 0 {
			return iNdEx, nil
		}
	}
	return 0, io.ErrUnexpectedEOF
}

var (
	ErrInvalidLengthAuthsessionTl        = fmt.Errorf("proto: negative length found during unmarshaling")
	ErrIntOverflowAuthsessionTl          = fmt.Errorf("proto: integer overflow")
	ErrUnexpectedEndOfGroupAuthsessionTl = fmt.Errorf("proto: unexpected end of group")
)
